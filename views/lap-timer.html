<!DOCTYPE html>
<html>
<head>
    <title>F1 Lap Timer Overlay</title>
    <link rel="stylesheet" href="/fonts.css">
    <link rel="stylesheet" href="/styles-lap-timer.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/textfit@2.4.0/textFit.min.js"></script>
    <script src="/utils/driver-utils.js"></script>
</head>
<body>
    <div class="overlay-container">
        <!-- DRIVER INFO BAR (top section) -->
        <div class="driver-info-group">
            <div class="position-layer">1</div>
            <div class="team-logo-layer"></div>
            <div class="driver-name-layer">VERSTAPPEN</div>
            <div class="tyre-compound-layer">S</div>
            <div id="knockout-indicator" class="knockout-indicator-layer"></div>
            <div class="position-indicators">
                <div id="position-gained-indicator" class="position-gained-indicator"></div>
                <div id="position-lost-indicator" class="position-lost-indicator"></div>
            </div>
        </div>

        <!-- TIMING DISPLAY (main section) -->
        <div class="timing-group">
            <div id="timer-background"></div>
            
            <!-- Main timing display (slides up during last lap popup) -->
            <div class="main-timing-display">
                <div id="separator"></div>
                <div id="lap-time" class="lap-time-layer">1:34.4</div>
                <div id="lap-time-comparison" class="lap-time-comparison-layer">1:39.432</div>
                <div id="lap-time-comparison-name" class="lap-time-comparison-name-layer">MAX VERSTAPPEN</div>
            </div>
            
            <!-- Last lap popup (slides down) -->
            <div id="last-lap-time" class="last-lap-time-layer">1:39.875</div>
            
            <!-- Sector deltas (overlay on timing display) -->
            <div class="sector-deltas">
                <div id="sector1-delta" class="sector-display-layer">27.8</div>
                <div id="sector2-delta" class="sector-display-layer">1:02.6</div>
                <div id="last-lap-delta" class="sector-display-layer">--:--.-</div>
            </div>
        </div>

        <!-- SECTOR BAR (bottom section) -->
        <div class="sector-bar-group">
            <div id="sectors-background"></div>
            <div id="sector-line"></div>
            
            <div class="sector-indicators">
                <div id="sector1-indicator" class="sector1-indicator"></div>
                <div id="sector2-indicator" class="sector2-indicator"></div>
                <div id="sector3-indicator" class="sector3-indicator"></div>
            </div>
            
            <div class="sector-labels">
                <div id="sector1-text" class="sector1-text-layer">S1</div>
                <div id="sector2-text" class="sector2-text-layer">S2</div>
                <div id="sector3-text" class="sector3-text-layer">S3</div>
            </div>
        </div>

        <!-- ROLEX WIDGET (displayed above driver info during sector completion) -->
        <div id="rolex-widget" class="rolex-widget">
            <img id="rolex-logo" src="/images/other-logos/Rolex.png">
        </div>

        <!-- DECORATIVE STROKE BAR -->
        <div id="stroke-bar" class="stroke-bar"></div>
    </div>
    <script>
        const socket = io();
        socket.emit('identify', 'Lap Timer');
        
        const overlayContainer = document.querySelector('.overlay-container');
        
        // Visibility mode from controller
        let visibilityMode = 'automatic'; // off, automatic, always-on
        let isInitialConfigLoad = true; // Track first config load to prevent flash
        
        // Handle overlay visibility mode from controller
        socket.on('overlay_config', (config) => {
            if (config.overlays && config.overlays['lap-timer']) {
                const newMode = config.overlays['lap-timer'].visibilityMode || 'automatic';
                const modeChanged = newMode !== visibilityMode;
                visibilityMode = newMode;
                
                // On initial load, set state without animation
                if (isInitialConfigLoad) {
                    isInitialConfigLoad = false;
                    if (visibilityMode === 'off') {
                        // Keep overlay hidden (already is)
                        shouldShowOverlay = false;
                    } else if (visibilityMode === 'always-on') {
                        // Show immediately without animation
                        overlayContainer.style.left = '0px';
                        overlayContainer.style.width = '480px';
                        overlayContainer.style.opacity = '1';
                        shouldShowOverlay = true;
                    }
                    // For 'automatic', overlay stays hidden until game data says otherwise
                } else if (modeChanged) {
                    // Mode changed after initial load - animate the change
                    if (visibilityMode === 'off') {
                        animateOverlayVisibility(false);
                        shouldShowOverlay = false;
                    } else if (visibilityMode === 'always-on') {
                        animateOverlayVisibility(true);
                        shouldShowOverlay = true;
                    }
                    // For 'automatic', let existing logic determine visibility
                }
            }
        });
        
        const lapTimeElement = document.getElementById('lap-time');
        const lastLapTimeElement = document.getElementById('last-lap-time');
        const lapTimeComparisonElement = document.getElementById('lap-time-comparison');
        const lapTimeComparisonNameElement = document.getElementById('lap-time-comparison-name');
        const separatorElement = document.getElementById('separator');
        const sector1TextElement = document.getElementById('sector1-text');
        const sector2TextElement = document.getElementById('sector2-text');
        const sector3TextElement = document.getElementById('sector3-text');
        const positionElement = document.querySelector('.position-layer');
        const driverNameElement = document.querySelector('.driver-name-layer');
        const tyreCompoundElement = document.querySelector('.tyre-compound-layer');
        const teamLogoElement = document.querySelector('.team-logo-layer');
        const sector1DeltaElement = document.getElementById('sector1-delta');
        const sector2DeltaElement = document.getElementById('sector2-delta');
        const lastLapDeltaElement = document.getElementById('last-lap-delta');
        const knockoutIndicator = document.getElementById('knockout-indicator');
        const positionGainedIndicator = document.getElementById('position-gained-indicator');
        const positionLostIndicator = document.getElementById('position-lost-indicator');
        const sector1Indicator = document.getElementById('sector1-indicator');
        const sector2Indicator = document.getElementById('sector2-indicator');
        const sector3Indicator = document.getElementById('sector3-indicator');
        const rolexWidget = document.getElementById('rolex-widget');

        // Constants
        const SESSION_TYPE = {
            UNKNOWN: 0,
            PRACTICE_1: 1,
            PRACTICE_2: 2,
            PRACTICE_3: 3,
            SHORT_PRACTICE: 4,
            QUALIFYING_1: 5,
            QUALIFYING_2: 6,
            QUALIFYING_3: 7,
            SHORT_QUALIFYING: 8,
            ONE_SHOT_QUALIFYING: 9,
            SPRINT_SHOOTOUT_1: 10,
            SPRINT_SHOOTOUT_2: 11,
            SPRINT_SHOOTOUT_3: 12,
            SHORT_SPRINT_SHOOTOUT: 13,
            ONE_SHOT_SPRINT_SHOOTOUT: 14,
            RACE: 15,
            RACE_2: 16,
            RACE_3: 17,
            TIME_TRIAL: 18
        };

        const ANIMATION_DURATION = {
            SECTOR_DELTA_FADE_IN: 100,
            SECTOR_DELTA_DISPLAY: 3000,
            SECTOR_DELTA_FADE_OUT: 500,
            LAST_LAP_SLIDE_UP: 333,
            LAST_LAP_DISPLAY: 5667,
            LAST_LAP_SLIDE_DOWN: 333,
            POSITION_CHANGE_FADE_IN: 500,
            POSITION_CHANGE_DISPLAY: 2000,
            POSITION_CHANGE_FADE_OUT: 500
        };

        const TYRE_COMPOUND = {
            SOFT: { code: 'S', color: '#F92D29' }, // Soft, Red
            MEDIUM: { code: 'M', color: '#EBD25F' }, // Medium, Yellow
            HARD: { code: 'H', color: '#FFFFFF' }, // Hard, White
            INTER: { code: 'I', color: '#3AC82B' }, // Intermediate, Green
            WET: { code: 'W', color: '#4491D2' }, // Wet, Blue
            SUPER_SOFT: { code: 'SS', color: '#800080' }, // Super Soft (F2 only), Purple
            UNKNOWN: { code: '?', color: '#808080' } // Compound is unknown
        };

        const SECTOR_COLORS = {
            FASTER: 'lime',      // Faster than reference
            SLOWER: '#FDD30A',   // Slower than reference (yellow)
            NEUTRAL: '#ffffff',  // No reference available
            PERSONAL_BEST: 'lime',
            OVERALL_BEST: 'magenta',
            DEFAULT: 'gold',
            GRAY: 'gray'
        };

        // Visual tyre compound ID mappings from F1 game telemetry
        const VISUAL_TYRE_COMPOUND = {
            7: 'I',   // Intermediate
            8: 'W',   // Wet
            15: 'W',  // Wet (F2)
            16: 'S',  // Soft (F1)
            17: 'M',  // Medium (F1)
            18: 'H',  // Hard (F1)
            19: 'SS', // Super Soft (F2)
            20: 'S',  // Soft (F2)
            21: 'M',  // Medium (F2)
            22: 'H'   // Hard (F2)
        };

        let currentLapTime = 'N/A';
        let lastLapTime = 'N/A';
        let lapTimeComparison = 'N/A';
        let lapTimeComparisonName = 'WAITING FOR GAME';
        let transitionValue = 'N/A';
        let position = '0';
        let prevPosition = '1';
        let driverName = 'PLAYER';
        let tyreCompound = 'S';
        let sessionType = 0;
        let formulaType = DriverUtils.FORMULA_TYPE.F1_MODERN;
        let leaderCarIdx = -1;
        let targetCarIdx = -1;
        let numActiveCars = 20;
        let currentLapNum = 0;
        let playerCarIdx = -1;
        let participants = []; // Store full participant data
        let participantNames = {};
        let teamNames = {};
        let customDrivers = [];
        let aiDrivers = {};
        let prevLastLapTimeMS = -1;
        let refSector1TimeMS = -1;
        let refSector2TimeMS = -1;
        let refLastLapTimeMS = -1;
        let prevSector1TimeMS = -1;
        let prevSector2TimeMS = -1;
        let canUpdateReference = true;
        let canUpdateComparison = true;
        let prevSector = -1;
        let currentLapSectorSum = 0;
        const sessionHistoryByCarIdx = {};
        const overallBestSectors = { s1: -1, s2: -1, s3: -1 };
        let newCurrentLapNum = -1;
        let trackLength = -1;
        let safetyCarStatus = 0;
        let shouldShowOverlay = false;
        let overlayAnimating = false;
        
        // Timeout tracking for cleanup
        let sectorResetTimeouts = [null, null, null];
        let comparisonUpdateTimeout = null;

        // Receive and process drivers data from server
        socket.on('drivers_data', (data) => {
            aiDrivers = data;
            console.log('AI drivers updated from server:', aiDrivers);
        });

        // Load driver data using DriverUtils
        async function loadDriverData() {
            try {
                const data = await DriverUtils.loadDriverData(formulaType);
                customDrivers = data.customDrivers;
                teamNames = data.teamNames;
                console.log('[LapTimer] Loaded driver data:', customDrivers.length, 'custom drivers');
            } catch (error) {
                console.error('[LapTimer] Error loading driver data:', error);
                teamNames = {};
                customDrivers = [];
            }
        }

        function formatTime(milliseconds) {
            if (milliseconds < 10000) {
                const seconds = Math.floor(milliseconds / 1000);
                const ms = Math.floor(milliseconds % 1000 / 100);
                return `${seconds}.${ms}`;
            } else if (milliseconds < 60000) {
                const seconds = Math.floor(milliseconds / 1000);
                const ms = Math.floor(milliseconds % 1000 / 100);
                return `${String(seconds).padStart(2, '0')}.${ms}`;
            } else {
                const minutes = Math.floor(milliseconds / 60000);
                const seconds = Math.floor((milliseconds % 60000) / 1000);
                const ms = Math.floor(milliseconds % 1000 / 100);
                return `${minutes}:${String(seconds).padStart(2, '0')}.${ms}`;
            }
        }

        function formatComparisonTime(milliseconds) {
            if (milliseconds < 60000) {
                const seconds = Math.floor(milliseconds / 1000);
                const ms = milliseconds % 1000;
                return `${seconds}.${String(ms).padStart(3, '0')}`;
            } else {
                const minutes = Math.floor(milliseconds / 60000);
                const seconds = Math.floor((milliseconds % 60000) / 1000);
                const ms = milliseconds % 1000;
                return `${minutes}:${String(seconds).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
            }
        }

        // Adjust driver name styling based on length using textFit
        function updateDriverNameStyling(name) {
            const nameLength = name.length;
            
            // Apply font-weight and font-stretch based on name length
            if (nameLength <= 10) {
                driverNameElement.style.fontWeight = "700";
                driverNameElement.style.fontStretch = "normal";
            } else {
                driverNameElement.style.fontWeight = "400";
                driverNameElement.style.fontStretch = "condensed";
            }
            
            // Use textFit to auto-resize font to fit container
            textFit(driverNameElement, {
                minFontSize: 22,
                maxFontSize: 32,
                multiLine: false,
                alignHoriz: true,
                alignVert: false,
                widthOnly: true
            });
        }

        function calculateSectorTime(minutesPart, msPart) {
            return minutesPart * 60000 + msPart;
        }

        function calculateCombinedSectorTime(s1MinutesPart, s1MsPart, s2MinutesPart, s2MsPart) {
            return calculateSectorTime(s1MinutesPart, s1MsPart) + calculateSectorTime(s2MinutesPart, s2MsPart);
        }

        /**
         * Display sector/lap time with delta comparison
         * @param {HTMLElement} element - The delta display element
         * @param {number} currentTimeMS - Current sector/lap time in milliseconds
         * @param {number} referenceTimeMS - Reference time to compare against (or -1 if none)
         * @param {number} currentSessionType - Current session type
         */
        function displayTimeDelta(element, currentTimeMS, referenceTimeMS, currentSessionType) {
            // Show delta if reference exists and session is Time Trial or any racing session
            const hasReference = referenceTimeMS > 0 && (currentSessionType === SESSION_TYPE.TIME_TRIAL || (currentSessionType >= SESSION_TYPE.PRACTICE_1 && currentSessionType <= SESSION_TYPE.TIME_TRIAL));
            
            if (hasReference) {
                // Show delta comparison
                const delta = currentTimeMS - referenceTimeMS;
                element.textContent = `${delta >= 0 ? '+' : '-'}${formatComparisonTime(Math.abs(delta))}`;
                element.style.color = delta >= 0 ? SECTOR_COLORS.SLOWER : SECTOR_COLORS.FASTER;
            } else {
                // Show absolute time
                element.textContent = formatComparisonTime(currentTimeMS);
                element.style.color = SECTOR_COLORS.NEUTRAL;
            }
        }

        /**
         * Store session history data for a car
         */
        function storeSessionHistory(data) {
            sessionHistoryByCarIdx[data.m_carIdx] = {
                numLaps: data.m_numLaps,
                bestLapNum: data.m_bestLapTimeLapNum,
                bestSector1LapNum: data.m_bestSector1LapNum,
                bestSector2LapNum: data.m_bestSector2LapNum,
                bestSector3LapNum: data.m_bestSector3LapNum,
                lapHistory: data.m_lapHistoryData
            };
        }

        /**
         * Update reference times from target car's best lap
         */
        function updateReferenceTimesFromHistory(data) {
            const historyData = data.m_lapHistoryData;
            const bestLapNum = data.m_bestLapTimeLapNum;
            
            // Validate history data exists and best lap is valid
            if (!historyData || bestLapNum <= 0 || bestLapNum > historyData.length) {
                // No valid best lap yet - hide comparison
                lapTimeComparisonElement.style.display = 'none';
                lapTimeComparisonNameElement.style.display = 'none';
                refSector1TimeMS = -1;
                refSector2TimeMS = -1;
                refLastLapTimeMS = -1;
                return;
            }

            const bestLap = historyData[bestLapNum - 1];
            const isRace = [SESSION_TYPE.RACE, SESSION_TYPE.RACE_2, SESSION_TYPE.RACE_3].includes(sessionType);
            
            // Set comparison name
            if (isRace) {
                lapTimeComparisonName = 'PERSONAL BEST';
            } else {
                lapTimeComparisonName = participantNames[targetCarIdx] || 'UNKNOWN';
            }
            
            // Show/hide comparison display based on session and lap
            if (isRace && currentLapNum < 3) {
                // Hide comparison for first 2 laps in races
                lapTimeComparisonElement.style.display = 'none';
                lapTimeComparisonNameElement.style.display = 'none';
            } else {
                lapTimeComparisonElement.style.display = 'flex';
                lapTimeComparisonNameElement.style.display = 'flex';
            }
            
            // Update reference times from best lap
            refSector1TimeMS = calculateSectorTime(bestLap.m_sector1TimeMinutesPart, bestLap.m_sector1TimeMSPart);
            refSector2TimeMS = calculateCombinedSectorTime(
                bestLap.m_sector1TimeMinutesPart,
                bestLap.m_sector1TimeMSPart,
                bestLap.m_sector2TimeMinutesPart,
                bestLap.m_sector2TimeMSPart
            );
            refLastLapTimeMS = bestLap.m_lapTimeInMS;
        }

        /**
         * Calculate overall best sectors across all cars in the session
         * Used for purple/magenta sector indicator colors
         */
        function updateOverallBestSectors() {
            for (let idx in sessionHistoryByCarIdx) {
                const history = sessionHistoryByCarIdx[idx];
                
                // Get best sector times for this car
                const s1Time = history.lapHistory[history.bestSector1LapNum - 1]
                    ? calculateSectorTime(
                        history.lapHistory[history.bestSector1LapNum - 1].m_sector1TimeMinutesPart,
                        history.lapHistory[history.bestSector1LapNum - 1].m_sector1TimeMSPart
                    )
                    : -1;
                    
                const s2Time = history.lapHistory[history.bestSector2LapNum - 1]
                    ? calculateSectorTime(
                        history.lapHistory[history.bestSector2LapNum - 1].m_sector2TimeMinutesPart,
                        history.lapHistory[history.bestSector2LapNum - 1].m_sector2TimeMSPart
                    )
                    : -1;
                    
                const s3Time = history.lapHistory[history.bestSector3LapNum - 1]
                    ? calculateSectorTime(
                        history.lapHistory[history.bestSector3LapNum - 1].m_sector3TimeMinutesPart,
                        history.lapHistory[history.bestSector3LapNum - 1].m_sector3TimeMSPart
                    )
                    : -1;
                
                // Update overall bests if this car's sector is faster
                if (s1Time > 0 && (overallBestSectors.s1 === -1 || s1Time < overallBestSectors.s1)) {
                    overallBestSectors.s1 = s1Time;
                }
                if (s2Time > 0 && (overallBestSectors.s2 === -1 || s2Time < overallBestSectors.s2)) {
                    overallBestSectors.s2 = s2Time;
                }
                if (s3Time > 0 && (overallBestSectors.s3 === -1 || s3Time < overallBestSectors.s3)) {
                    overallBestSectors.s3 = s3Time;
                }
            }
        }

        /**
         * Handle Session packet (ID: 1)
         * Updates session type and formula type, loads appropriate custom driver data
         */
        function handleSessionPacket(data) {
            const newSessionType = data.m_sessionType;
            const newFormulaType = data.m_formula;
            
            // Store track length and safety car status for overlay visibility calculations
            trackLength = data.m_trackLength || -1;
            safetyCarStatus = data.m_safetyCarStatus || 0;
            
            // Only reload custom drivers if formula type changed
            if (formulaType !== newFormulaType) {
                sessionType = newSessionType;
                formulaType = newFormulaType;
                console.log('[LapTimer] Formula type:', formulaType);
                loadDriverData();
            } else {
                sessionType = newSessionType;
                formulaType = newFormulaType;
            }
        }

        /**
         * Handle Participants packet (ID: 4)
         * Updates driver names for all participants in the session using DriverUtils
         */
        function handleParticipantsPacket(data) {
            numActiveCars = data.m_participants.length;
            participants = data.m_participants;
            participantNames = {};
            
            participants.forEach((participant, i) => {
                const index = participant.m_participantIndex !== undefined ? participant.m_participantIndex : i;
                
                // Get driver name using DriverUtils
                const driverName = DriverUtils.getDriverLastName(
                    participant,
                    aiDrivers,
                    customDrivers,
                    teamNames
                );
                participantNames[index] = driverName.toUpperCase();
                
                // Update team logo if this is the player
                if (i === playerCarIdx) {
                    updateTeamLogo(participant.m_teamId);
                }
            });
            
            updateLapDisplay();
        }

        /**
         * Handle Car Status packet (ID: 7)
         * Updates tyre compound for the player
         */
        function handleCarStatusPacket(data) {
            const playerIndex = data.m_header.m_playerCarIndex;
            const carStatus = data.m_carStatusData[playerIndex];
            
            if (carStatus) {
                const visualTyreCompound = carStatus.m_visualTyreCompound;
                tyreCompound = VISUAL_TYRE_COMPOUND[visualTyreCompound] || '?';
                updateLapDisplay();
            }
        }

        /**
         * Handle sector completion - show delta, update sector bar colors
         * @param {number} sectorNum - Sector number (0=S1, 1=S2, 2=S3)
         * @param {number} sectorTimeMS - Time for this sector only
         * @param {number} cumulativeTimeMS - Cumulative time (S1+S2 for sector 2, full lap for sector 3)
         * @param {number} refTimeMS - Reference time to compare against
         */
        function handleSectorCompletion(sectorNum, sectorTimeMS, cumulativeTimeMS, refTimeMS) {
            const deltaElement = [sector1DeltaElement, sector2DeltaElement, lastLapDeltaElement][sectorNum];
            deltaElement.style.opacity = '1';
            lapTimeElement.style.opacity = '0'; // Hide lap time while delta is showing
            displayTimeDelta(deltaElement, cumulativeTimeMS, refTimeMS, sessionType);
            
            // Get personal best for this sector
            const sectorKey = ['bestSector1LapNum', 'bestSector2LapNum', 'bestSector3LapNum'][sectorNum];
            const sectorField = ['m_sector1TimeMSPart', 'm_sector2TimeMSPart', 'm_sector3TimeMSPart'][sectorNum];
            const sectorMinField = ['m_sector1TimeMinutesPart', 'm_sector2TimeMinutesPart', 'm_sector3TimeMinutesPart'][sectorNum];
            
            const history = sessionHistoryByCarIdx[playerCarIdx];
            const bestLapNum = history?.[sectorKey];
            const bestLap = history?.lapHistory?.[bestLapNum - 1];
            
            const personalBest = (bestLap && bestLap[sectorField] !== undefined)
                ? calculateSectorTime(bestLap[sectorMinField], bestLap[sectorField])
                : -1;
            
            // Determine sector bar color (gold -> lime -> magenta)
            let color = SECTOR_COLORS.DEFAULT;
            if (sectorTimeMS < personalBest || personalBest === -1) color = SECTOR_COLORS.PERSONAL_BEST;
            if (sectorTimeMS < overallBestSectors[['s1', 's2', 's3'][sectorNum]] || overallBestSectors[['s1', 's2', 's3'][sectorNum]] === -1) {
                color = SECTOR_COLORS.OVERALL_BEST;
            }
            
            // Update sector indicator and text
            setSectorIndicator(sectorNum, color);
            setSectorText(sectorNum, ['SECTOR 1', 'SECTOR 2', 'SECTOR 3'][sectorNum], color);
            rolexWidget.style.opacity = '1';
            
            // For Sector 3, hide delta early (2s) to avoid conflict with last lap popup
            if (sectorNum === 2) {
                setTimeout(() => {
                    deltaElement.style.opacity = '0';
                }, 2000);
            }
            
            // Clear existing timeout for this sector to prevent overlaps (e.g., spectator mode cycling)
            if (sectorResetTimeouts[sectorNum]) {
                clearTimeout(sectorResetTimeouts[sectorNum]);
            }
            
            // Reset after 4 seconds (or 6 for sector 3)
            const displayDuration = sectorNum === 2 ? 6000 : 4000;
            sectorResetTimeouts[sectorNum] = setTimeout(() => {
                if (sectorNum !== 2) {
                    // S1/S2: Hide delta, show lap time again
                    deltaElement.style.opacity = '0';
                    lapTimeElement.style.opacity = '1';
                }
                // Note: For sector 3, lap time opacity is managed by handleLastLapAnimation
                
                setSectorText(sectorNum, ['S1', 'S2', 'S3'][sectorNum], color);
                rolexWidget.style.opacity = '0';
                
                // For sector 3, also reset all indicators
                if (sectorNum === 2) {
                    setSectorIndicator(0, 'transparent');
                    setSectorIndicator(1, 'transparent');
                    setSectorIndicator(2, 'transparent');
                    setSectorText(0, 'S1', SECTOR_COLORS.GRAY);
                    setSectorText(1, 'S2', SECTOR_COLORS.GRAY);
                    setSectorText(2, 'S3', SECTOR_COLORS.GRAY);
                    currentLapSectorSum = 0;
                }
                sectorResetTimeouts[sectorNum] = null;
            }, displayDuration);
        }

        /**
         * Handle last lap completion - animate last lap time display
         */
        function handleLastLapAnimation(lastLapTimeMS, newLapTime) {
            const mainTimingDisplay = document.querySelector('.main-timing-display');
            
            // Initialize positions
            lastLapTimeElement.style.opacity = '0';
            
            // Slide last lap time down into view, main timing display down out of view
            anime({
                targets: lastLapTimeElement,
                top: '0px',
                opacity: 1,
                duration: ANIMATION_DURATION.LAST_LAP_SLIDE_UP,
                easing: 'easeInOutQuad'
            });
            
            anime({
                targets: mainTimingDisplay,
                top: '100px',
                opacity: 0,
                duration: ANIMATION_DURATION.LAST_LAP_SLIDE_UP,
                easing: 'easeInOutQuad'
            });
            
            // Slide back after display duration
            setTimeout(() => {
                anime({
                    targets: lastLapTimeElement,
                    top: '-80px',
                    opacity: 0,
                    duration: ANIMATION_DURATION.LAST_LAP_SLIDE_DOWN,
                    easing: 'easeInOutQuad'
                });
                anime({
                    targets: mainTimingDisplay,
                    top: '0px',
                    opacity: 1,
                    duration: ANIMATION_DURATION.LAST_LAP_SLIDE_DOWN,
                    easing: 'easeInOutQuad',
                    complete: () => {
                        // Restore lap time visibility after animation completes
                        lapTimeElement.style.opacity = '1';
                    }
                });
            }, ANIMATION_DURATION.LAST_LAP_DISPLAY);
        }

        /**
         * Update target car index based on session type and position
         */
        function updateTargetCar(allLapData, currentPosition) {
            // Find leader
            for (let i = 0; i < allLapData.length; i++) {
                if (allLapData[i].m_carPosition === 1) {
                    leaderCarIdx = i;
                    break;
                }
            }
            
            targetCarIdx = leaderCarIdx; // Default to leader
            
            // Q1/Sprint Shootout 1 - compare to knockout threshold
            if ([SESSION_TYPE.QUALIFYING_1, SESSION_TYPE.SPRINT_SHOOTOUT_1].includes(sessionType)) {
                const threshold = numActiveCars === 20 ? DriverUtils.KNOCKOUT_ZONE_POSITIONS.Q1_20_CARS : DriverUtils.KNOCKOUT_ZONE_POSITIONS.Q1_22_CARS;
                if (currentPosition > threshold) {
                    for (let i = 0; i < allLapData.length; i++) {
                        if (allLapData[i].m_carPosition === threshold) {
                            targetCarIdx = i;
                            if (sessionHistoryByCarIdx[targetCarIdx]?.bestLapNum < 1) {
                                targetCarIdx = leaderCarIdx; // Fallback if no valid lap
                            }
                            break;
                        }
                    }
                }
            }
            // Q2/Sprint Shootout 2 - compare to P10
            else if ([SESSION_TYPE.QUALIFYING_2, SESSION_TYPE.SPRINT_SHOOTOUT_2].includes(sessionType)) {
                if (currentPosition > DriverUtils.KNOCKOUT_ZONE_POSITIONS.Q2) {
                    for (let i = 0; i < allLapData.length; i++) {
                        if (allLapData[i].m_carPosition === DriverUtils.KNOCKOUT_ZONE_POSITIONS.Q2) {
                            targetCarIdx = i;
                            if (sessionHistoryByCarIdx[targetCarIdx]?.bestLapNum < 1) {
                                targetCarIdx = leaderCarIdx;
                            }
                            break;
                        }
                    }
                }
            }
            // Race - compare to self
            else if ([SESSION_TYPE.RACE, SESSION_TYPE.RACE_2, SESSION_TYPE.RACE_3].includes(sessionType)) {
                targetCarIdx = playerCarIdx;
            }
        }

        /**
         * Handle position change animations
         */
        function handlePositionChange(newPosition) {
            if (newPosition === prevPosition) return;
            
            const positionChange = newPosition - prevPosition;
            
            if (positionChange < 0) {
                // Position gained
                positionGainedIndicator.style.opacity = '1';
                positionLostIndicator.style.opacity = '0';
                anime({
                    targets: positionGainedIndicator,
                    opacity: [1, 0],
                    duration: ANIMATION_DURATION.POSITION_CHANGE_DISPLAY,
                    easing: 'easeInOutQuad',
                    complete: () => positionGainedIndicator.style.opacity = '0'
                });
            } else if (positionChange > 0) {
                // Position lost
                positionLostIndicator.style.opacity = '1';
                positionGainedIndicator.style.opacity = '0';
                anime({
                    targets: positionLostIndicator,
                    opacity: [1, 0],
                    duration: ANIMATION_DURATION.POSITION_CHANGE_DISPLAY,
                    easing: 'easeInOutQuad',
                    complete: () => positionLostIndicator.style.opacity = '0'
                });
            }
            
            prevPosition = newPosition;
        }

        /**
         * Animate overlay visibility with slide and fade effect
         * @param {boolean} show - Whether to show or hide the overlay
         */
        function animateOverlayVisibility(show) {
            if (overlayAnimating) return; // Prevent overlapping animations
            
            // Check if already in target state to avoid unnecessary animation
            const currentOpacity = parseFloat(overlayContainer.style.opacity) || 0;
            const isCurrentlyVisible = currentOpacity > 0.5;
            if (show === isCurrentlyVisible) return; // Already in target state
            
            overlayAnimating = true;

            const duration = 200; // 0.2 seconds (inertia with changespersecond=5)
            
            if (show) {
                // Slide in from right, expand width, fade in
                anime({
                    targets: overlayContainer,
                    left: [240, 0],
                    width: [0, 480],
                    opacity: [0, 1],
                    duration: duration,
                    easing: 'easeOutQuad',
                    complete: () => overlayAnimating = false
                });
            } else {
                // Slide out to right, collapse width, fade out
                // Reset sector indicators and text when hiding overlay
                setSectorIndicator(0, 'transparent');
                setSectorIndicator(1, 'transparent');
                setSectorIndicator(2, 'transparent');
                setSectorText(0, 'S1', SECTOR_COLORS.GRAY);
                setSectorText(1, 'S2', SECTOR_COLORS.GRAY);
                setSectorText(2, 'S3', SECTOR_COLORS.GRAY);
                rolexWidget.style.opacity = '0';
                
                anime({
                    targets: overlayContainer,
                    left: [0, 240],
                    width: [480, 0],
                    opacity: [1, 0],
                    duration: duration,
                    easing: 'easeInQuad',
                    complete: () => overlayAnimating = false
                });
            }
        }

        /**
         * Calculate if overlay should be visible based on session type and driver status
         * @param {number} driverStatus - Current driver status (0=garage, 1=flying, 2=in lap, 3=out lap, 4=on track)
         * @param {number} lapDistance - Current lap distance
         * @returns {boolean} Whether overlay should be visible
         */
        function calculateOverlayVisibility(driverStatus, lapDistance) {
            // Rule 1: Always hide in garage (defensive check - highest priority)
            if (driverStatus === 0) {
                return false;
            }

            // Rule 2: Practice/Qualifying (1-14) - show after 90% lap distance on out lap
            if (sessionType >= SESSION_TYPE.PRACTICE_1 && sessionType <= SESSION_TYPE.ONE_SHOT_SPRINT_SHOOTOUT) {
                if (driverStatus === 3) { // Out lap
                    if (trackLength <= 0) {
                        return false;
                    }
                    
                    // Show when 90% of lap completed
                    if (lapDistance < 0) {
                        // Handle negative lap distance (first out lap only)
                        // Show when within last 10% (e.g., if track is 5000m, show when lapDistance > -500)
                        const threshold = -(trackLength * 0.1);
                        return lapDistance > threshold;
                    } else {
                        // Positive lap distance - normal calculation
                        return (lapDistance / trackLength) >= 0.9;
                    }
                }
                // Once out of out lap status, keep visible until garage
                return shouldShowOverlay; // Maintain previous state
            }

            // Rule 3: Race (15-17) - always visible (except garage and formation lap)
            if (sessionType >= SESSION_TYPE.RACE && sessionType <= SESSION_TYPE.RACE_3) {
                // Hide during formation lap (safetyCarStatus === 3)
                if (safetyCarStatus === 3) {
                    return false;
                }
                return true;
            }

            // Rule 4: Time Trial (18) - visible when not in garage
            if (sessionType === SESSION_TYPE.TIME_TRIAL) {
                return true;
            }

            // Default: visible
            return true;
        }

        /**
         * Handle Session History packet (ID: 11)
         * Stores lap history, updates reference times, and calculates overall best sectors
         */
        function handleSessionHistoryPacket(data) {
            if (!canUpdateReference) {
                return;
            }

            // Store session history for this car (works for all session types)
            storeSessionHistory(data);
            
            // Update reference times if this is the target car we're comparing against
            // (Not used in Time Trial - that uses Packet 14 instead)
            if (sessionType !== SESSION_TYPE.TIME_TRIAL && data.m_carIdx === targetCarIdx && targetCarIdx !== -1) {
                updateReferenceTimesFromHistory(data);
            }
            
            // Calculate overall best sectors across all cars (for purple sector indicators)
            updateOverallBestSectors();
        }

        /**
         * Handle Time Trial packet (ID: 14)
         * Updates reference times from personal best in Time Trial mode
         * Uses m_personalBestDataSet to maintain persistent comparison across sessions
         */
        function handleTimeTrialPacket(data) {
            // Only process in Time Trial mode and when updates are allowed (not immediately after crossing line)
            if (sessionType !== SESSION_TYPE.TIME_TRIAL || !canUpdateReference) {
                return;
            }

            const personalBestData = data.m_personalBestDataSet;
            const personalBestTime = personalBestData?.m_lapTimeInMS;
            
            if (personalBestTime != null && personalBestTime > 0) {
                // Valid personal best exists - show comparison and update reference times
                lapTimeComparisonName = 'PERSONAL BEST';
                lapTimeComparisonElement.style.display = 'flex';
                lapTimeComparisonNameElement.style.display = 'flex';
                
                // Set sector reference times (Sector 2 is cumulative: S1 + S2)
                refSector1TimeMS = personalBestData.m_sector1TimeInMS || -1;
                refSector2TimeMS = (personalBestData.m_sector1TimeInMS || 0) + (personalBestData.m_sector2TimeInMS || 0);
                refLastLapTimeMS = personalBestTime;
            } else {
                // No personal best yet - hide comparison display
                lapTimeComparisonElement.style.display = 'none';
                lapTimeComparisonNameElement.style.display = 'none';
                refSector1TimeMS = -1;
                refSector2TimeMS = -1;
                refLastLapTimeMS = -1;
            }
        }

        function updateLapDisplay() {
            lapTimeElement.textContent = currentLapTime;
            lastLapTimeElement.textContent = lastLapTime;
            lapTimeComparisonElement.textContent = transitionValue;
            lapTimeComparisonNameElement.textContent = lapTimeComparisonName.toUpperCase();
            sector1TextElement.textContent = sector1TextElement.textContent || 'S1';
            sector2TextElement.textContent = sector2TextElement.textContent || 'S2';
            sector3TextElement.textContent = sector3TextElement.textContent || 'S3';
            positionElement.textContent = position;
            driverNameElement.textContent = driverName.toUpperCase();
            updateDriverNameStyling(driverName.toUpperCase());
            tyreCompoundElement.textContent = tyreCompound;
            positionElement.style.color = knockoutIndicator.style.display === 'block' ? '#C0C0C0' : '#000000'; // Silver when knockout is active, black otherwise
            
            // Update tyre compound color using constants
            const tyreConfig = {
                'S': TYRE_COMPOUND.SOFT,
                'M': TYRE_COMPOUND.MEDIUM,
                'H': TYRE_COMPOUND.HARD,
                'I': TYRE_COMPOUND.INTER,
                'W': TYRE_COMPOUND.WET,
                'SS': TYRE_COMPOUND.SUPER_SOFT
            }[tyreCompound] || TYRE_COMPOUND.UNKNOWN;
            
            tyreCompoundElement.textContent = tyreConfig.code;
            tyreCompoundElement.style.color = tyreConfig.color;

            if (currentLapTime.includes(':')) {
                const [minutes] = currentLapTime.split(':').map(Number);
                if (minutes >= 1) {
                    lapTimeElement.style.left = '38px';
                } else {
                    lapTimeElement.style.left = '65px';
                }
            } else if (parseInt(currentLapTime) < 10) {
                lapTimeElement.style.left = '115px';
            } else {
                lapTimeElement.style.left = '65px';
            }
        }

        function updateTeamLogo(teamId) {
            const teamData = teamNames[teamId];
            
            if (teamData && teamData.Logo) {
                // Team data exists, use the specified logo
                const logoPath = `/images/team-logos/${teamData.Logo}`;
                const img = new Image();
                
                img.onload = () => {
                    // Image loaded successfully, use the CSS background color and set the image
                    teamLogoElement.style.backgroundColor = '#081425';
                    teamLogoElement.style.backgroundImage = `url(${logoPath})`;
                };
                
                img.onerror = () => {
                    // Image failed to load, set to transparent with no image
                    teamLogoElement.style.backgroundColor = 'transparent';
                    teamLogoElement.style.backgroundImage = 'none';
                };
                
                img.src = logoPath;
            } else {
                // No team data found, set to transparent with no image
                teamLogoElement.style.backgroundColor = 'transparent';
                teamLogoElement.style.backgroundImage = 'none';
            }
        }

        function setSectorIndicator(sector, color) {
            const indicator = {
                0: sector1Indicator,
                1: sector2Indicator,
                2: sector3Indicator
            }[sector];
            indicator.style.backgroundColor = color || 'transparent';
            indicator.style.opacity = color ? '1' : '0';
        }

        function setSectorText(sector, text, color) {
            const textElement = {
                0: sector1TextElement,
                1: sector2TextElement,
                2: sector3TextElement
            }[sector];
            textElement.textContent = text;
            textElement.style.color = color || 'gray';
        }
        
        function createStrokeBar() {
            const strokeBar = document.getElementById('stroke-bar');
            const rectCount = Math.ceil(480 / 7); // adjust 7 for density/spacing
            for (let i = 0; i < rectCount; i++) {
                const rect = document.createElement('div');
                rect.className = 'stroke-rect';
                strokeBar.appendChild(rect);
            }
        }   

        socket.on('f1_data', (data) => {
            const packetId = data.m_header.m_packetId;

            if (packetId === 1) {
                handleSessionPacket(data);
            } else if (packetId === 2) {
                const playerIndex = data.m_header.m_playerCarIndex;
                const lapData = data.m_lapData[playerIndex];

                if (lapData) {
                    playerCarIdx = playerIndex;
                    position = lapData.m_carPosition || '1';
                    driverName = participantNames[playerCarIdx] || 'UNKNOWN';
                    
                    // === OVERLAY VISIBILITY CONTROL ===
                    // Only apply automatic visibility if mode is 'automatic'
                    if (visibilityMode === 'automatic') {
                        const driverStatus = lapData.m_driverStatus;
                        const lapDistance = lapData.m_lapDistance;
                        const newOverlayVisibility = calculateOverlayVisibility(driverStatus, lapDistance);
                        
                        if (newOverlayVisibility !== shouldShowOverlay) {
                            shouldShowOverlay = newOverlayVisibility;
                            animateOverlayVisibility(shouldShowOverlay);
                        }
                    }
                    // For 'off' and 'always-on', visibility is controlled by config handler
                    
                    // === CURRENT LAP TIME DISPLAY ===
                    const newLapTime = lapData.m_currentLapTimeInMS;
                    if (newLapTime >= 0) currentLapTime = formatTime(newLapTime);
                    
                    // === LAST LAP COMPLETION ===
                    const lastLapTimeMS = lapData.m_lastLapTimeInMS;
                    if (lastLapTimeMS > 0) {
                        lastLapTime = formatComparisonTime(lastLapTimeMS);
                        newCurrentLapNum = lapData.m_currentLapNum || 0;
                        
                        // Display last lap time after 2 seconds into new lap
                        if ((lastLapTimeMS !== prevLastLapTimeMS || newCurrentLapNum !== currentLapNum) && newLapTime > 2000) {
                            prevLastLapTimeMS = lastLapTimeMS;
                            currentLapNum = newCurrentLapNum;
                            lastLapTimeElement.innerText = formatComparisonTime(lastLapTimeMS);
                            handleLastLapAnimation(lastLapTimeMS, newLapTime);
                        }
                        
                        // Show last lap delta and calculate Sector 3
                        if ((lastLapTimeMS !== prevLastLapTimeMS || newCurrentLapNum !== currentLapNum) && newCurrentLapNum > 1) {
                            const sector3TimeMS = lastLapTimeMS - currentLapSectorSum;
                            if (sector3TimeMS > 0) {
                                handleSectorCompletion(2, sector3TimeMS, lastLapTimeMS, refLastLapTimeMS);
                                canUpdateReference = false;
                                setTimeout(() => canUpdateReference = true, 2000);
                            }
                        }
                    }
                    
                    // === LAP COMPARISON UPDATES ===
                    const currentSector = lapData.m_sector;
                    
                    // Calculate what the comparison value should be for current sector
                    let newComparisonValue = 'N/A';
                    if (refSector1TimeMS > 0 && currentSector === 0) {
                        newComparisonValue = formatComparisonTime(refSector1TimeMS);
                    } else if (refSector2TimeMS > 0 && currentSector === 1) {
                        newComparisonValue = formatComparisonTime(refSector2TimeMS);
                    } else if (refLastLapTimeMS > 0 && currentSector === 2) {
                        newComparisonValue = formatComparisonTime(refLastLapTimeMS);
                    }
                    
                    // When sector changes, lock comparison updates for 4 seconds (while delta is showing)
                    if (prevSector !== currentSector) {
                        prevSector = currentSector;
                        canUpdateComparison = false;
                        
                        // Clear existing comparison timeout to prevent overlaps
                        if (comparisonUpdateTimeout) {
                            clearTimeout(comparisonUpdateTimeout);
                        }
                        
                        comparisonUpdateTimeout = setTimeout(() => {
                            canUpdateComparison = true;
                            lapTimeComparison = newComparisonValue;
                            transitionValue = newComparisonValue;
                            updateLapDisplay();
                            comparisonUpdateTimeout = null;
                        }, 4000); // Update after sector delta disappears
                    } else if (canUpdateComparison) {
                        // Only update when not locked (prevents constant overwriting at 60 Hz)
                        lapTimeComparison = newComparisonValue;
                        transitionValue = newComparisonValue;
                        updateLapDisplay();
                    }
                    
                    // === TARGET CAR SELECTION ===
                    updateTargetCar(data.m_lapData, position);
                    
                    // === KNOCKOUT INDICATOR ===
                const isKnockoutVisible = DriverUtils.isInKnockoutZone(position, sessionType, numActiveCars);
                    knockoutIndicator.style.display = isKnockoutVisible ? 'block' : 'none';
                    
                    // === POSITION CHANGE ANIMATIONS ===
                    handlePositionChange(position);
                    
                    // === SECTOR 1 COMPLETION ===
                    const sector1TimeMS = calculateSectorTime(lapData.m_sector1TimeMinutesPart, lapData.m_sector1TimeMSPart);
                    if (sector1TimeMS > 0 && sector1TimeMS !== prevSector1TimeMS) {
                        handleSectorCompletion(0, sector1TimeMS, sector1TimeMS, refSector1TimeMS);
                        prevSector1TimeMS = sector1TimeMS;
                        currentLapSectorSum = sector1TimeMS;
                    }
                    
                    // === SECTOR 2 COMPLETION ===
                    const sector2TimeMS = calculateSectorTime(lapData.m_sector2TimeMinutesPart, lapData.m_sector2TimeMSPart);
                    const combinedTimeMS = calculateCombinedSectorTime(lapData.m_sector1TimeMinutesPart, lapData.m_sector1TimeMSPart, 
                                                                        lapData.m_sector2TimeMinutesPart, lapData.m_sector2TimeMSPart);
                    if (sector2TimeMS > 0 && combinedTimeMS !== prevSector2TimeMS) {
                        handleSectorCompletion(1, sector2TimeMS, combinedTimeMS, refSector2TimeMS);
                        prevSector2TimeMS = combinedTimeMS;
                        currentLapSectorSum = combinedTimeMS;
                    }
                    
                    updateLapDisplay();
                }
            } else if (packetId === 4) {
                handleParticipantsPacket(data);
            } else if (packetId === 7) {
                handleCarStatusPacket(data);
            } else if (packetId === 11) {
                handleSessionHistoryPacket(data);
            } else if (packetId === 14) {
                handleTimeTrialPacket(data);
            }
        });
        
        // Initialize overlay as hidden
        overlayContainer.style.left = '240px';
        overlayContainer.style.width = '0px';
        overlayContainer.style.opacity = '0';
        
        createStrokeBar();
        updateLapDisplay();
        loadDriverData();
    </script>
</body>
</html>