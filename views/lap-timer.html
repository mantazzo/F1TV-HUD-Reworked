<!DOCTYPE html>
<html>
<head>
    <title>F1 Lap Timer Overlay</title>
    <link rel="stylesheet" href="/fonts.css">
    <link rel="stylesheet" href="/styles-lap-timer.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>
<body>
    <div class="overlay-container">
        <div class="position-layer">1</div>
        <div class="team-logo-layer"></div>
        <div class="driver-name-layer">VERSTAPPEN</div>
        <div class="tyre-compound-layer">S</div>
        <div id="knockout-indicator" class="knockout-indicator-layer"></div>
        <div id="sector1-delta" class="sector-display-layer">27.8</div>
        <div id="sector2-delta" class="sector-display-layer">1:02.6</div>
        <div id="last-lap-delta" class="sector-display-layer">--:--.-</div>
        <div id="timer-background"></div>
        <div id="sectors-background"></div>
        <div id="separator"></div>
        <div id="lap-time" class="lap-time-layer">1:34.4</div>
        <div id="last-lap-time" class="last-lap-time-layer">1:39.875</div>
        <div id="lap-time-comparison" class="lap-time-comparison-layer">1:39.432</div>
        <div id="lap-time-comparison-name" class="lap-time-comparison-name-layer">MAX VERSTAPPEN</div>
        <div id="sector-line"></div>
        <div id="sector1-indicator" class="sector1-indicator"></div>
        <div id="sector2-indicator" class="sector2-indicator"></div>
        <div id="sector3-indicator" class="sector3-indicator"></div>
        <div id="sector1-text" class="sector1-text-layer">S1</div>
        <div id="sector2-text" class="sector2-text-layer">S2</div>
        <div id="sector3-text" class="sector3-text-layer">S3</div>
        <div id="position-gained-indicator" class="position-gained-indicator"></div>
        <div id="position-lost-indicator" class="position-lost-indicator"></div>
        <div id="stroke-bar" class="stroke-bar"></div>
        <div id="rolex-widget" class="rolex-widget">
            <img id="rolex-logo" src="/images/other-logos/Rolex.png">
        </div>
    </div>
    <script>
        const socket = io();
        const lapTimeElement = document.getElementById('lap-time');
        const lastLapTimeElement = document.getElementById('last-lap-time');
        const lapTimeComparisonElement = document.getElementById('lap-time-comparison');
        const lapTimeComparisonNameElement = document.getElementById('lap-time-comparison-name');
        const separatorElement = document.getElementById('separator');
        const sector1TextElement = document.getElementById('sector1-text');
        const sector2TextElement = document.getElementById('sector2-text');
        const sector3TextElement = document.getElementById('sector3-text');
        const positionElement = document.querySelector('.position-layer');
        const driverNameElement = document.querySelector('.driver-name-layer');
        const tyreCompoundElement = document.querySelector('.tyre-compound-layer');
        const teamLogoElement = document.querySelector('.team-logo-layer');
        const sector1DeltaElement = document.getElementById('sector1-delta');
        const sector2DeltaElement = document.getElementById('sector2-delta');
        const lastLapDeltaElement = document.getElementById('last-lap-delta');
        const knockoutIndicator = document.getElementById('knockout-indicator');
        const positionGainedIndicator = document.getElementById('position-gained-indicator');
        const positionLostIndicator = document.getElementById('position-lost-indicator');
        const sector1Indicator = document.getElementById('sector1-indicator');
        const sector2Indicator = document.getElementById('sector2-indicator');
        const sector3Indicator = document.getElementById('sector3-indicator');
        const rolexWidget = document.getElementById('rolex-widget');

        // Constants
        const SESSION_TYPE = {
            UNKNOWN: 0,
            PRACTICE_1: 1,
            PRACTICE_2: 2,
            PRACTICE_3: 3,
            SHORT_PRACTICE: 4,
            QUALIFYING_1: 5,
            QUALIFYING_2: 6,
            QUALIFYING_3: 7,
            SHORT_QUALIFYING: 8,
            ONE_SHOT_QUALIFYING: 9,
            SPRINT_SHOOTOUT_1: 10,
            SPRINT_SHOOTOUT_2: 11,
            SPRINT_SHOOTOUT_3: 12,
            SHORT_SPRINT_SHOOTOUT: 13,
            ONE_SHOT_SPRINT_SHOOTOUT: 14,
            RACE: 15,
            RACE_2: 16,
            RACE_3: 17,
            TIME_TRIAL: 18
        };

        const ANIMATION_DURATION = {
            SECTOR_DELTA_FADE_IN: 100,
            SECTOR_DELTA_DISPLAY: 3000,
            SECTOR_DELTA_FADE_OUT: 500,
            LAST_LAP_SLIDE_UP: 333,
            LAST_LAP_DISPLAY: 5000,
            LAST_LAP_SLIDE_DOWN: 333,
            POSITION_CHANGE_FADE_IN: 500,
            POSITION_CHANGE_DISPLAY: 2000,
            POSITION_CHANGE_FADE_OUT: 500
        };

        const TYRE_COMPOUND = {
            SOFT: { code: 'S', color: '#F92D29' }, // Soft, Red
            MEDIUM: { code: 'M', color: '#EBD25F' }, // Medium, Yellow
            HARD: { code: 'H', color: '#FFFFFF' }, // Hard, White
            INTER: { code: 'I', color: '#3AC82B' }, // Intermediate, Green
            WET: { code: 'W', color: '#4491D2' }, // Wet, Blue
            SUPER_SOFT: { code: 'SS', color: '#800080' }, // Super Soft (F2 only), Purple
            UNKNOWN: { code: '?', color: '#808080' } // Compound is unknown
        };

        const KNOCKOUT_ZONE_POSITIONS = {
            Q1_20_CARS: 15,  // 20 car grid
            Q1_22_CARS: 16,  // 22 car grid (F2 or MyTeam)
            Q2: 10,
            Q3: 0  // No knockout in Q3
        };

        const SECTOR_COLORS = {
            FASTER: 'lime',      // Faster than reference
            SLOWER: '#FDD30A',   // Slower than reference (yellow)
            NEUTRAL: '#ffffff',  // No reference available
            PERSONAL_BEST: 'lime',
            OVERALL_BEST: 'magenta',
            DEFAULT: 'gold',
            GRAY: 'gray'
        };

        // Visual tyre compound ID mappings from F1 game telemetry
        const VISUAL_TYRE_COMPOUND = {
            7: 'I',   // Intermediate
            8: 'W',   // Wet
            15: 'W',  // Wet (F2)
            16: 'S',  // Soft (F1)
            17: 'M',  // Medium (F1)
            18: 'H',  // Hard (F1)
            19: 'SS', // Super Soft (F2)
            20: 'S',  // Soft (F2)
            21: 'M',  // Medium (F2)
            22: 'H'   // Hard (F2)
        };

        let currentLapTime = 'N/A';
        let lastLapTime = 'N/A';
        let lapTimeComparison = 'N/A';
        let lapTimeComparisonName = 'WAITING FOR GAME';
        let transitionValue = 'N/A';
        let isTransitioning = false;
        let position = '0';
        let prevPosition = '1';
        let driverName = 'PLAYER';
        let tyreCompound = 'S';
        let sessionType = 0;
        let formulaType = 0;
        let leaderCarIdx = -1;
        let targetCarIdx = -1;
        let numActiveCars = 20;
        let currentLapNum = 0;
        let playerCarIdx = -1;
        let participantNames = {};
        let teamNames = {};
        let customDrivers = [];
        let aiDrivers = {};
        let prevLastLapTimeMS = -1;
        let refSector1TimeMS = -1;
        let refSector2TimeMS = -1;
        let refLastLapTimeMS = -1;
        let prevSector1TimeMS = -1;
        let prevSector2TimeMS = -1;
        let canUpdateReference = true;
        let prevSector = -1;
        let sectorTimeout = null;
        let currentLapSectorSum = 0;
        const sessionHistoryByCarIdx = {};
        const overallBestSectors = { s1: -1, s2: -1, s3: -1 };
        let newCurrentLapNum = -1;
        let hideCurrentTime = false;

        // Receive and process drivers data from server
        socket.on('drivers_data', (data) => {
            aiDrivers = data;
            console.log('AI drivers updated from server:', aiDrivers);
        });

        async function loadJsonFiles() {
            try {
                const promises = [
                    fetch('/data/DefaultTeams.json')
                ];
                if (formulaType === 0) {
                    promises.push(fetch('/data/CustomF1Drivers.json'));
                } else if (formulaType === 2) {
                    promises.push(fetch('/data/CustomF2Drivers.json'));
                }
                const responses = await Promise.all(promises.map(p => p.catch(() => null)));
                teamNames = responses[0] ? await responses[0].json() : {};
                if (responses[1]) {
                    const customDriversData = await responses[1].json();
                    customDrivers = Array.isArray(customDriversData) ? customDriversData : [];
                    console.log(`Custom drivers loaded for ${formulaType === 0 ? 'F1' : formulaType === 2 ? 'F2' : 'Unknown Formula'} (${customDrivers.length} drivers):`, customDrivers);
                }
            } catch (error) {
                console.error('Error loading JSON files:', error);
                teamNames = {};
                customDrivers = [];
            }
        }

        function matchCustomDriver(participant) {
            const raceNumber = participant.m_raceNumber;
            const name = participant.m_name;
            const teamId = participant.m_teamId;
            const team = teamNames[teamId] ? teamNames[teamId].ShortName : `Team_${teamId}`;

            // Priority 1: Exact name match (MatchName field)
            for (let driver of customDrivers) {
                if (driver.MatchName && driver.MatchName.toUpperCase() === name.toUpperCase()) {
                    return driver.LastName || driver.DisplayName || '';
                }
            }

            // Priority 2: Number + Team match
            for (let driver of customDrivers) {
                if (driver.RaceNumber && driver.Team && driver.RaceNumber === raceNumber && driver.Team === team) {
                    return driver.LastName || driver.DisplayName || '';
                }
            }

            // Priority 3: Number only match
            for (let driver of customDrivers) {
                if (driver.RaceNumber && driver.RaceNumber === raceNumber) {
                    return driver.LastName || driver.DisplayName || '';
                }
            }

            // No match - return fallback
            return `${team} #${raceNumber}`;
        }

        function formatTime(milliseconds) {
            if (milliseconds < 10000) {
                const seconds = Math.floor(milliseconds / 1000);
                const ms = Math.floor(milliseconds % 1000 / 100);
                return `${seconds}.${ms}`;
            } else if (milliseconds < 60000) {
                const seconds = Math.floor(milliseconds / 1000);
                const ms = Math.floor(milliseconds % 1000 / 100);
                return `${String(seconds).padStart(2, '0')}.${ms}`;
            } else {
                const minutes = Math.floor(milliseconds / 60000);
                const seconds = Math.floor((milliseconds % 60000) / 1000);
                const ms = Math.floor(milliseconds % 1000 / 100);
                return `${minutes}:${String(seconds).padStart(2, '0')}.${ms}`;
            }
        }

        function formatComparisonTime(milliseconds) {
            if (milliseconds < 60000) {
                const seconds = Math.floor(milliseconds / 1000);
                const ms = milliseconds % 1000;
                return `${seconds}.${String(ms).padStart(3, '0')}`;
            } else {
                const minutes = Math.floor(milliseconds / 60000);
                const seconds = Math.floor((milliseconds % 60000) / 1000);
                const ms = milliseconds % 1000;
                return `${minutes}:${String(seconds).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
            }
        }

        // Change the font style for longer names
        function updateDriverNameStyling(name) {
            const nameLength = name.length;
            
            if (nameLength <= 10) {
                // Default styling for short names
                driverNameElement.style.fontFamily = "F1TV-2022-ObliqueBold";
                driverNameElement.style.fontSize = "32px";
            } else if (nameLength <= 12) {
                // Condensed font for names 11-12 characters
                driverNameElement.style.fontFamily = "F1TV-2022-ObliqueCondensed";
                driverNameElement.style.fontSize = "32px";
            } else if (nameLength === 13) {
                // Condensed font + smaller size for names 13 characters (and we reduce the size more for 14, 15 and more characters)
                driverNameElement.style.fontFamily = "F1TV-2022-ObliqueCondensed";
                driverNameElement.style.fontSize = "30px";
            } else if (nameLength === 14) {
                driverNameElement.style.fontFamily = "F1TV-2022-ObliqueCondensed";
                driverNameElement.style.fontSize = "28px";
            } else if (nameLength === 15) {
                driverNameElement.style.fontFamily = "F1TV-2022-ObliqueCondensed";
                driverNameElement.style.fontSize = "26px";
            } else {
                // Smallest size for names longer than 15 characters
                driverNameElement.style.fontFamily = "F1TV-2022-ObliqueCondensed";
                driverNameElement.style.fontSize = "24px";
            }
        }

        function calculateSectorTime(minutesPart, msPart) {
            return minutesPart * 60000 + msPart;
        }

        function calculateCombinedSectorTime(s1MinutesPart, s1MsPart, s2MinutesPart, s2MsPart) {
            return calculateSectorTime(s1MinutesPart, s1MsPart) + calculateSectorTime(s2MinutesPart, s2MsPart);
        }

        /**
         * Display sector/lap time with delta comparison
         * @param {HTMLElement} element - The delta display element
         * @param {number} currentTimeMS - Current sector/lap time in milliseconds
         * @param {number} referenceTimeMS - Reference time to compare against (or -1 if none)
         * @param {number} currentSessionType - Current session type
         */
        function displayTimeDelta(element, currentTimeMS, referenceTimeMS, currentSessionType) {
            // Show delta if reference exists and session is Time Trial or any racing session
            const hasReference = referenceTimeMS > 0 && (currentSessionType === SESSION_TYPE.TIME_TRIAL || (currentSessionType >= SESSION_TYPE.PRACTICE_1 && currentSessionType <= SESSION_TYPE.TIME_TRIAL));
            
            if (hasReference) {
                // Show delta comparison
                const delta = currentTimeMS - referenceTimeMS;
                element.textContent = `${delta >= 0 ? '+' : '-'}${formatComparisonTime(Math.abs(delta))}`;
                element.style.color = delta >= 0 ? SECTOR_COLORS.SLOWER : SECTOR_COLORS.FASTER;
            } else {
                // Show absolute time
                element.textContent = formatComparisonTime(currentTimeMS);
                element.style.color = SECTOR_COLORS.NEUTRAL;
            }
        }

        /**
         * Handle Session packet (ID: 1)
         * Updates session type and formula type, loads appropriate custom driver data
         */
        function handleSessionPacket(data) {
            const newSessionType = data.m_sessionType;
            const newFormulaType = data.m_formula;
            
            // Only reload custom drivers if formula type changed or first load
            if (formulaType !== newFormulaType || !customDrivers.length) {
                sessionType = newSessionType;
                formulaType = newFormulaType;
                loadJsonFiles();
            } else {
                sessionType = newSessionType;
                formulaType = newFormulaType;
            }
        }

        /**
         * Handle Participants packet (ID: 4)
         * Updates driver names for all participants in the session
         */
        function handleParticipantsPacket(data) {
            numActiveCars = data.m_participants.length;
            participantNames = {};
            
            for (let i = 0; i < numActiveCars && i < data.m_participants.length; i++) {
                const participant = data.m_participants[i];
                const index = participant.m_participantIndex !== undefined ? participant.m_participantIndex : i;
                const driverId = participant.m_driverId;
                
                if (driverId === 255) {
                    // Human player - use custom driver match
                    participantNames[index] = matchCustomDriver(participant);
                } else {
                    // AI driver - use lastName from driversData
                    const aiDriver = aiDrivers[driverId];
                    participantNames[index] = aiDriver ? aiDriver.lastName.toUpperCase() : 'UNKNOWN_AI';
                }
                
                // Update team logo if this is the player
                if (i === playerCarIdx) {
                    updateTeamLogo(participant.m_teamId);
                }
            }
            
            updateLapDisplay();
        }

        /**
         * Handle Car Status packet (ID: 7)
         * Updates tyre compound for the player
         */
        function handleCarStatusPacket(data) {
            const playerIndex = data.m_header.m_playerCarIndex;
            const carStatus = data.m_carStatusData[playerIndex];
            
            if (carStatus) {
                const visualTyreCompound = carStatus.m_visualTyreCompound;
                tyreCompound = VISUAL_TYRE_COMPOUND[visualTyreCompound] || '?';
                updateLapDisplay();
            }
        }

        /**
         * Handle Time Trial packet (ID: 14)
         * Updates reference times from personal best in Time Trial mode
         * Uses m_personalBestDataSet to maintain persistent comparison across sessions
         */
        function handleTimeTrialPacket(data) {
            // Only process in Time Trial mode and when updates are allowed (not immediately after crossing line)
            if (sessionType !== SESSION_TYPE.TIME_TRIAL || !canUpdateReference) {
                return;
            }

            const personalBestData = data.m_personalBestDataSet;
            const personalBestTime = personalBestData?.m_lapTimeInMS;
            
            if (personalBestTime != null && personalBestTime > 0) {
                // Valid personal best exists - show comparison and update reference times
                lapTimeComparisonName = 'PERSONAL BEST';
                lapTimeComparisonElement.style.display = 'flex';
                lapTimeComparisonNameElement.style.display = 'flex';
                
                // Set sector reference times (Sector 2 is cumulative: S1 + S2)
                refSector1TimeMS = personalBestData.m_sector1TimeInMS || -1;
                refSector2TimeMS = (personalBestData.m_sector1TimeInMS || 0) + (personalBestData.m_sector2TimeInMS || 0);
                refLastLapTimeMS = personalBestTime;
            } else {
                // No personal best yet - hide comparison display
                lapTimeComparisonElement.style.display = 'none';
                lapTimeComparisonNameElement.style.display = 'none';
                refSector1TimeMS = -1;
                refSector2TimeMS = -1;
                refLastLapTimeMS = -1;
            }
        }

        function updateLapDisplay() {
            lapTimeElement.textContent = currentLapTime;
            lastLapTimeElement.textContent = lastLapTime;
            lapTimeComparisonElement.textContent = transitionValue;
            lapTimeComparisonNameElement.textContent = lapTimeComparisonName.toUpperCase();
            sector1TextElement.textContent = sector1TextElement.textContent || 'S1';
            sector2TextElement.textContent = sector2TextElement.textContent || 'S2';
            sector3TextElement.textContent = sector3TextElement.textContent || 'S3';
            positionElement.textContent = position;
            driverNameElement.textContent = driverName.toUpperCase();
            updateDriverNameStyling(driverName.toUpperCase());
            tyreCompoundElement.textContent = tyreCompound;
            positionElement.style.color = knockoutIndicator.style.display === 'block' ? '#C0C0C0' : '#000000'; // Silver when knockout is active, black otherwise
            
            // Update tyre compound color using constants
            const tyreConfig = {
                'S': TYRE_COMPOUND.SOFT,
                'M': TYRE_COMPOUND.MEDIUM,
                'H': TYRE_COMPOUND.HARD,
                'I': TYRE_COMPOUND.INTER,
                'W': TYRE_COMPOUND.WET,
                'SS': TYRE_COMPOUND.SUPER_SOFT
            }[tyreCompound] || TYRE_COMPOUND.UNKNOWN;
            
            tyreCompoundElement.textContent = tyreConfig.code;
            tyreCompoundElement.style.color = tyreConfig.color;

            if (currentLapTime.includes(':')) {
                const [minutes] = currentLapTime.split(':').map(Number);
                if (minutes >= 1) {
                    lapTimeElement.style.left = '38px';
                } else {
                    lapTimeElement.style.left = '65px';
                }
            } else if (parseInt(currentLapTime) < 10) {
                lapTimeElement.style.left = '115px';
            } else {
                lapTimeElement.style.left = '65px';
            }
        }

        function updateTeamLogo(teamId) {
            const teamData = teamNames[teamId];
            
            if (teamData && teamData.Logo) {
                // Team data exists, use the specified logo
                const logoPath = `/images/team-logos/${teamData.Logo}`;
                const img = new Image();
                
                img.onload = () => {
                    // Image loaded successfully, use the CSS background color and set the image
                    teamLogoElement.style.backgroundColor = '#081425';
                    teamLogoElement.style.backgroundImage = `url(${logoPath})`;
                };
                
                img.onerror = () => {
                    // Image failed to load, set to transparent with no image
                    teamLogoElement.style.backgroundColor = 'transparent';
                    teamLogoElement.style.backgroundImage = 'none';
                };
                
                img.src = logoPath;
            } else {
                // No team data found, set to transparent with no image
                teamLogoElement.style.backgroundColor = 'transparent';
                teamLogoElement.style.backgroundImage = 'none';
            }
        }

        function setSectorIndicator(sector, color) {
            const indicator = {
                0: sector1Indicator,
                1: sector2Indicator,
                2: sector3Indicator
            }[sector];
            indicator.style.backgroundColor = color || 'transparent';
            indicator.style.opacity = color ? '1' : '0';
        }

        function setSectorText(sector, text, color) {
            const textElement = {
                0: sector1TextElement,
                1: sector2TextElement,
                2: sector3TextElement
            }[sector];
            textElement.textContent = text;
            textElement.style.color = color || 'gray';
        }
        
        function createStrokeBar() {
            const strokeBar = document.getElementById('stroke-bar');
            const rectCount = Math.ceil(480 / 7); // adjust 7 for density/spacing
            for (let i = 0; i < rectCount; i++) {
                const rect = document.createElement('div');
                rect.className = 'stroke-rect';
                strokeBar.appendChild(rect);
            }
        }   

        socket.on('f1_data', (data) => {
            const packetId = data.m_header.m_packetId;

            if (packetId === 1) {
                handleSessionPacket(data);
            } else if (packetId === 2) {
                const playerIndex = data.m_header.m_playerCarIndex;
                const lapData = data.m_lapData[playerIndex];

                if (lapData) {
                    const newLapTime = lapData.m_currentLapTimeInMS;
                    if (newLapTime >= 0) currentLapTime = formatTime(newLapTime);
                    if (lapData.m_driverStatus === 0) { // Hide while "In garage"
                        lapTimeElement.style.opacity = 0;
                    } else if (!hideCurrentTime) { // Show if not hidden otherwise
                        lapTimeElement.style.opacity = 1;
                    }
                    const lastLapTimeMS = lapData.m_lastLapTimeInMS;
                    if (lastLapTimeMS > 0) {
                        lastLapTime = formatComparisonTime(lastLapTimeMS);
                        newCurrentLapNum = lapData.m_currentLapNum || 0;
                        if ((lastLapTimeMS !== prevLastLapTimeMS || newCurrentLapNum !== currentLapNum) && newLapTime > 2000) {
                            prevLastLapTimeMS = lastLapTimeMS;
                            currentLapNum = newCurrentLapNum;
                            lastLapTimeElement.style.top = `${parseInt(getComputedStyle(lastLapTimeElement).top) || 57}px`;
                            lastLapTimeElement.style.opacity = '0';
                            [lapTimeComparisonElement, lapTimeComparisonNameElement, separatorElement, lapTimeElement].forEach(el => {
                                el.style.top = `${parseInt(getComputedStyle(el).top) || 0}px`;
                                // el.style.opacity = '1';
                            });
                            anime.timeline({ easing: 'easeInOutQuad' })
                                .add({
                                    targets: lastLapTimeElement,
                                    top: function(el) { return (parseInt(getComputedStyle(el).top) || 57) + 80 + 'px'; },
                                    opacity: 1,
                                    duration: 333
                                });
                            anime({
                                targets: [lapTimeComparisonElement, lapTimeComparisonNameElement, separatorElement, lapTimeElement],
                                top: function(el) { return (parseInt(getComputedStyle(el).top) || 0) - 100 + 'px'; },
                                opacity: 0,
                                duration: 333,
                                easing: 'easeInOutQuad'
                            });
                            setTimeout(() => {
                                anime({
                                    targets: lastLapTimeElement,
                                    top: function(el) { return (parseInt(getComputedStyle(el).top) || 137) - 80 + 'px'; },
                                    opacity: 0,
                                    duration: 333,
                                    easing: 'easeInOutQuad'
                                });
                                anime({
                                    targets: [lapTimeComparisonElement, lapTimeComparisonNameElement, separatorElement, lapTimeElement],
                                    top: function(el) { return (parseInt(getComputedStyle(el).top) || -100) + 100 + 'px'; },
                                    opacity: 1,
                                    duration: 333,
                                    easing: 'easeInOutQuad'
                                });
                            }, 3667);
                        }

                        // Last Lap Delta logic with flag to prevent updates
                        if ((lastLapTimeMS !== prevLastLapTimeMS || newCurrentLapNum !== currentLapNum) && newCurrentLapNum > 1) {
                            lapTimeElement.style.opacity = '0';
                            hideCurrentTime = true;
                            lastLapDeltaElement.style.opacity = '1';
                            canUpdateReference = false;
                            displayTimeDelta(lastLapDeltaElement, lastLapTimeMS, refLastLapTimeMS, sessionType);
                            setTimeout(() => {
                                lastLapDeltaElement.style.opacity = '0';
                                canUpdateReference = true;
                            }, 2000);
                            const sector3TimeMS = lastLapTimeMS - currentLapSectorSum;
                            if (sector3TimeMS > 0) {
                                const personalBestS3 = sessionHistoryByCarIdx[playerCarIdx]?.lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector3LapNum - 1]?.m_sector3TimeMSPart !== undefined
                                ? calculateSectorTime(sessionHistoryByCarIdx[playerCarIdx].lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector3LapNum - 1].m_sector3TimeMinutesPart,
                                                    sessionHistoryByCarIdx[playerCarIdx].lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector3LapNum - 1].m_sector3TimeMSPart)
                                : -1;
                                let color = SECTOR_COLORS.DEFAULT;
                                if (sector3TimeMS < personalBestS3 || personalBestS3 === -1) color = SECTOR_COLORS.PERSONAL_BEST;
                                if (sector3TimeMS < overallBestSectors.s3 || overallBestSectors.s3 === -1) color = SECTOR_COLORS.OVERALL_BEST;
                                setSectorIndicator(2, color);
                                setSectorText(2, 'SECTOR 3', color);
                                rolexWidget.style.opacity = '1';
                                setTimeout(() => {
                                    setSectorIndicator(2, 'transparent');
                                    setSectorText(2, 'S3', SECTOR_COLORS.GRAY);
                                    setSectorIndicator(0, 'transparent');
                                    setSectorIndicator(1, 'transparent');
                                    setSectorText(0, 'S1', SECTOR_COLORS.GRAY);
                                    setSectorText(1, 'S2', SECTOR_COLORS.GRAY);
                                    rolexWidget.style.opacity = '0';
                                    hideCurrentTime = false;
                                    currentLapSectorSum = 0; // Reset for next lap
                                }, 6000);
                            }
                        }
                    }

                    position = lapData.m_carPosition || '1';
                    playerCarIdx = playerIndex;
                    driverName = participantNames[playerCarIdx] || 'UNKNOWN';

                    // Dynamically update lap time comparison based on current sector
                    const currentSector = lapData.m_sector;
                    if (refSector1TimeMS > 0 && currentSector === 0) {
                        lapTimeComparison = formatComparisonTime(refSector1TimeMS);
                    } else if (refSector2TimeMS > 0 && currentSector === 1) {
                        lapTimeComparison = formatComparisonTime(refSector2TimeMS);
                    } else if (refLastLapTimeMS > 0 && currentSector === 2) {
                        lapTimeComparison = formatComparisonTime(refLastLapTimeMS);
                    } else {
                        lapTimeComparison = 'N/A';
                    }

                    // Trigger transition before switching text
                    if (prevSector !== currentSector) {
                        if (sectorTimeout) clearTimeout(sectorTimeout);
                        isTransitioning = true;
                        transitionValue = lapTimeComparisonElement.textContent;
                        sectorTimeout = setTimeout(() => {
                            transitionValue = lapTimeComparison;
                            isTransitioning = false;
                            updateLapDisplay();
                        }, 4000);
                    } else if (!isTransitioning) {
                        transitionValue = lapTimeComparison;
                        updateLapDisplay();
                    }

                    prevSector = currentSector;
                    
                    for (let i = 0; i < data.m_lapData.length; i++) {
                        if (data.m_lapData[i].m_carPosition === 1) {
                            leaderCarIdx = i;
                            break;
                        }
                    }
                    targetCarIdx = leaderCarIdx;
                    if ([SESSION_TYPE.QUALIFYING_1, SESSION_TYPE.SPRINT_SHOOTOUT_1].includes(sessionType)) {
                        const threshold = numActiveCars === 20 ? KNOCKOUT_ZONE_POSITIONS.Q1_20_CARS : KNOCKOUT_ZONE_POSITIONS.Q1_22_CARS;
                        if (position > threshold) {
                            for (let i = 0; i < data.m_lapData.length; i++) {
                                if (data.m_lapData[i].m_carPosition === threshold) {
                                    targetCarIdx = i;
                                    if (sessionHistoryByCarIdx[targetCarIdx]?.bestLapNum < 1) {
                                        targetCarIdx = leaderCarIdx;
                                    }
                                    break;
                                }
                            }
                        }
                    } else if ([SESSION_TYPE.QUALIFYING_2, SESSION_TYPE.SPRINT_SHOOTOUT_2].includes(sessionType)) {
                        if (position > KNOCKOUT_ZONE_POSITIONS.Q2) {
                            for (let i = 0; i < data.m_lapData.length; i++) {
                                if (data.m_lapData[i].m_carPosition === KNOCKOUT_ZONE_POSITIONS.Q2) {
                                    targetCarIdx = i;
                                    if (sessionHistoryByCarIdx[targetCarIdx]?.bestLapNum < 1) {
                                        targetCarIdx = leaderCarIdx;
                                    }
                                    break;
                                }
                            }
                        }
                    } else if ([SESSION_TYPE.RACE, SESSION_TYPE.RACE_2, SESSION_TYPE.RACE_3].includes(sessionType)) {
                        targetCarIdx = playerCarIdx;
                    }

                    // Knockout indicator display logic
                    const isQ1 = [SESSION_TYPE.QUALIFYING_1, SESSION_TYPE.SPRINT_SHOOTOUT_1].includes(sessionType);
                    const isQ2 = [SESSION_TYPE.QUALIFYING_2, SESSION_TYPE.SPRINT_SHOOTOUT_2].includes(sessionType);
                    
                    let isKnockoutVisible = false;
                    if ((isQ1 && ((numActiveCars === 20 && position > KNOCKOUT_ZONE_POSITIONS.Q1_20_CARS) || (numActiveCars === 22 && position > KNOCKOUT_ZONE_POSITIONS.Q1_22_CARS))) ||
                        (isQ2 && position > KNOCKOUT_ZONE_POSITIONS.Q2)) {
                        isKnockoutVisible = true;
                    }
                    knockoutIndicator.style.display = isKnockoutVisible ? 'block' : 'none';

                    // Position change indicators
                    if (position !== prevPosition) {
                        const positionChange = position - prevPosition;
                        if (positionChange < 0) { // Position gained
                            positionGainedIndicator.style.opacity = '1';
                            positionLostIndicator.style.opacity = '0';
                            anime({
                                targets: positionGainedIndicator,
                                opacity: [1, 0],
                                duration: 2000,
                                easing: 'easeInOutQuad',
                                complete: () => positionGainedIndicator.style.opacity = '0'
                            });
                        } else if (positionChange > 0) { // Position lost
                            positionLostIndicator.style.opacity = '1';
                            positionGainedIndicator.style.opacity = '0';
                            anime({
                                targets: positionLostIndicator,
                                opacity: [1, 0],
                                duration: 2000,
                                easing: 'easeInOutQuad',
                                complete: () => positionLostIndicator.style.opacity = '0'
                            });
                        }
                        prevPosition = position;
                    }

                    // Sector 1 delta logic with display mechanics
                    const sector1TimeMS = calculateSectorTime(lapData.m_sector1TimeMinutesPart, lapData.m_sector1TimeMSPart);
                    if (sector1TimeMS > 0 && sector1TimeMS !== prevSector1TimeMS) {
                        prevSector1TimeMS = sector1TimeMS;
                        lapTimeElement.style.opacity = '0';
                        hideCurrentTime = true;
                        sector1DeltaElement.style.opacity = '1';
                        displayTimeDelta(sector1DeltaElement, sector1TimeMS, refSector1TimeMS, sessionType);
                        const personalBestS1 = sessionHistoryByCarIdx[playerCarIdx]?.lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector1LapNum - 1]?.m_sector1TimeMSPart !== undefined
                            ? calculateSectorTime(sessionHistoryByCarIdx[playerCarIdx].lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector1LapNum - 1].m_sector1TimeMinutesPart,
                                                sessionHistoryByCarIdx[playerCarIdx].lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector1LapNum - 1].m_sector1TimeMSPart)
                            : -1;
                        let color = SECTOR_COLORS.DEFAULT;
                        if (sector1TimeMS < personalBestS1 || personalBestS1 === -1) color = SECTOR_COLORS.PERSONAL_BEST;
                        if (sector1TimeMS < overallBestSectors.s1 || overallBestSectors.s1 === -1) color = SECTOR_COLORS.OVERALL_BEST;
                        setSectorIndicator(0, color);
                        setSectorText(0, 'SECTOR 1', color);
                        rolexWidget.style.opacity = '1';
                        setTimeout(() => {
                            sector1DeltaElement.style.opacity = '0';
                            setSectorText(0, 'S1', color);
                            lapTimeElement.style.opacity = '1';
                            hideCurrentTime = false;
                            rolexWidget.style.opacity = '0';
                        }, 4000);
                    }

                    // Sector 2 delta logic with display mechanics
                    const sector2TimeMS = calculateSectorTime(lapData.m_sector2TimeMinutesPart, lapData.m_sector2TimeMSPart);
                    const combinedTimeMS = calculateCombinedSectorTime(lapData.m_sector1TimeMinutesPart, lapData.m_sector1TimeMSPart, lapData.m_sector2TimeMinutesPart, lapData.m_sector2TimeMSPart);
                    if (sector2TimeMS > 0 && combinedTimeMS !== prevSector2TimeMS) {
                        prevSector2TimeMS = combinedTimeMS;
                        lapTimeElement.style.opacity = '0';
                        hideCurrentTime = true;
                        sector2DeltaElement.style.opacity = '1';
                        displayTimeDelta(sector2DeltaElement, combinedTimeMS, refSector2TimeMS, sessionType);
                        currentLapSectorSum = combinedTimeMS;
                        const personalBestS2 = sessionHistoryByCarIdx[playerCarIdx]?.lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector2LapNum - 1]?.m_sector2TimeMSPart !== undefined
                            ? calculateSectorTime(sessionHistoryByCarIdx[playerCarIdx].lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector2LapNum - 1].m_sector2TimeMinutesPart,
                                                sessionHistoryByCarIdx[playerCarIdx].lapHistory[sessionHistoryByCarIdx[playerCarIdx].bestSector2LapNum - 1].m_sector2TimeMSPart)
                            : -1;
                        let color = SECTOR_COLORS.DEFAULT;
                        if (sector2TimeMS < personalBestS2 || personalBestS2 === -1) color = SECTOR_COLORS.PERSONAL_BEST;
                        if (sector2TimeMS < overallBestSectors.s2 || overallBestSectors.s2 === -1) color = SECTOR_COLORS.OVERALL_BEST;
                        setSectorIndicator(1, color);
                        setSectorText(1, 'SECTOR 2', color);
                        rolexWidget.style.opacity = '1';
                        setTimeout(() => {
                            sector2DeltaElement.style.opacity = '0';
                            setSectorText(1, 'S2', color);
                            lapTimeElement.style.opacity = '1';
                            hideCurrentTime = false;
                            rolexWidget.style.opacity = '0';
                        }, 4000);
                    }

                    updateLapDisplay();
                }
            } else if (packetId === 4) {
                handleParticipantsPacket(data);
            } else if (packetId === 7) {
                handleCarStatusPacket(data);
            } else if (packetId === 11) {
                if (canUpdateReference && sessionType >= SESSION_TYPE.PRACTICE_1 && sessionType < SESSION_TYPE.TIME_TRIAL) {
                    sessionHistoryByCarIdx[data.m_carIdx] = {
                        numLaps: data.m_numLaps,
                        bestLapNum: data.m_bestLapTimeLapNum,
                        bestSector1LapNum: data.m_bestSector1LapNum,
                        bestSector2LapNum: data.m_bestSector2LapNum,
                        bestSector3LapNum: data.m_bestSector3LapNum,
                        lapHistory: data.m_lapHistoryData
                    };
                    if (data.m_carIdx === targetCarIdx && targetCarIdx !== -1) {
                        const historyData = data.m_lapHistoryData;
                        const bestLapNum = data.m_bestLapTimeLapNum;
                        if (historyData && bestLapNum > 0 && bestLapNum <= historyData.length) {
                            if ([SESSION_TYPE.RACE, SESSION_TYPE.RACE_2, SESSION_TYPE.RACE_3].includes(sessionType)) {
                                lapTimeComparisonName = 'PERSONAL BEST';
                            } else if (targetCarIdx === leaderCarIdx) {
                                lapTimeComparisonName = 'LEADER';
                            } else if ([SESSION_TYPE.QUALIFYING_1, SESSION_TYPE.SPRINT_SHOOTOUT_1].includes(sessionType)) {
                                lapTimeComparisonName = `POS ${numActiveCars === 20 ? KNOCKOUT_ZONE_POSITIONS.Q1_20_CARS : KNOCKOUT_ZONE_POSITIONS.Q1_22_CARS}`;
                            } else if ([SESSION_TYPE.QUALIFYING_2, SESSION_TYPE.SPRINT_SHOOTOUT_2].includes(sessionType)) {
                                lapTimeComparisonName = 'POS 10';
                            } else {
                                lapTimeComparisonName = participantNames[targetCarIdx] || 'UNKNOWN';
                            }
                            if ([SESSION_TYPE.RACE, SESSION_TYPE.RACE_2, SESSION_TYPE.RACE_3].includes(sessionType)) {
                                if (currentLapNum < 3) {
                                    lapTimeComparisonElement.style.display = 'none';
                                    lapTimeComparisonNameElement.style.display = 'none';
                                } else {
                                    lapTimeComparisonElement.style.display = 'flex';
                                    lapTimeComparisonNameElement.style.display = 'flex';
                                }
                            } else {
                                lapTimeComparisonElement.style.display = 'flex';
                                lapTimeComparisonNameElement.style.display = 'flex';
                            }
                            refSector1TimeMS = calculateSectorTime(historyData[bestLapNum - 1].m_sector1TimeMinutesPart, historyData[bestLapNum - 1].m_sector1TimeMSPart);
                            refSector2TimeMS = calculateCombinedSectorTime(
                                historyData[bestLapNum - 1].m_sector1TimeMinutesPart,
                                historyData[bestLapNum - 1].m_sector1TimeMSPart,
                                historyData[bestLapNum - 1].m_sector2TimeMinutesPart,
                                historyData[bestLapNum - 1].m_sector2TimeMSPart
                            );
                            refLastLapTimeMS = historyData[bestLapNum - 1].m_lapTimeInMS;
                        } else {
                            lapTimeComparisonElement.style.display = 'none';
                            lapTimeComparisonNameElement.style.display = 'none';
                            refSector1TimeMS = -1;
                            refSector2TimeMS = -1;
                            refLastLapTimeMS = -1;
                        }
                    }
                } else if (canUpdateReference && sessionType === SESSION_TYPE.TIME_TRIAL) {
                    // We just need to store the data for overall best sectors when in Time Trial
                    sessionHistoryByCarIdx[data.m_carIdx] = {
                        numLaps: data.m_numLaps,
                        bestLapNum: data.m_bestLapTimeLapNum,
                        bestSector1LapNum: data.m_bestSector1LapNum,
                        bestSector2LapNum: data.m_bestSector2LapNum,
                        bestSector3LapNum: data.m_bestSector3LapNum,
                        lapHistory: data.m_lapHistoryData
                    };
                }
                // Update overall best sectors
                for (let idx in sessionHistoryByCarIdx) {
                    const history = sessionHistoryByCarIdx[idx];
                    const s1Time = history.lapHistory[history.bestSector1LapNum - 1]
                        ? calculateSectorTime(history.lapHistory[history.bestSector1LapNum - 1].m_sector1TimeMinutesPart,
                                            history.lapHistory[history.bestSector1LapNum - 1].m_sector1TimeMSPart)
                        : -1;
                    const s2Time = history.lapHistory[history.bestSector2LapNum - 1]
                        ? calculateSectorTime(history.lapHistory[history.bestSector2LapNum - 1].m_sector2TimeMinutesPart,
                                            history.lapHistory[history.bestSector2LapNum - 1].m_sector2TimeMSPart)
                        : -1;
                    const s3Time = history.lapHistory[history.bestSector3LapNum - 1]
                        ? calculateSectorTime(history.lapHistory[history.bestSector3LapNum - 1].m_sector3TimeMinutesPart,
                                            history.lapHistory[history.bestSector3LapNum - 1].m_sector3TimeMSPart)
                        : -1;
                    if (s1Time > 0 && (overallBestSectors.s1 === -1 || s1Time < overallBestSectors.s1)) overallBestSectors.s1 = s1Time;
                    if (s2Time > 0 && (overallBestSectors.s2 === -1 || s2Time < overallBestSectors.s2)) overallBestSectors.s2 = s2Time;
                    if (s3Time > 0 && (overallBestSectors.s3 === -1 || s3Time < overallBestSectors.s3)) overallBestSectors.s3 = s3Time;
                }
            } else if (packetId === 14) {
                handleTimeTrialPacket(data);
            }
        });
        createStrokeBar();
        updateLapDisplay();
        loadJsonFiles();
    </script>
</body>
</html>