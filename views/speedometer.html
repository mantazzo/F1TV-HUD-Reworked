<!DOCTYPE html>
<html>
<head>
    <title>F1 Speedometer Overlay</title>
    <link rel="stylesheet" href="/fonts.css">
    <link rel="stylesheet" href="/styles-speedometer.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>
<body>
    <div class="overlay-container">
        <!-- Background layer -->
        <div class="layer background-layer">
            <img src="/images/speedometer/F1TV_BG.png" alt="Background">
        </div>
        
        <!-- Value background layer -->
        <div class="layer gauge-layer">
            <img src="/images/speedometer/F1TV_ValueBG.png" alt="Gauge Background">
        </div>
        
        <!-- Gauge canvases layer -->
        <div class="layer gauges-layer">
            <!-- Speed gauge - item_22r0 -->
            <div class="dial-container speed-dial">
                <canvas id="speed-gauge" width="497" height="496"></canvas>
            </div>
            <!-- Brake gauge - item_23r0 -->
            <div class="dial-container brake-dial">
                <canvas id="brake-gauge" width="496.2" height="496.2"></canvas>
            </div>
            <!-- Throttle gauge - item_24r0 -->
            <div class="dial-container throttle-dial">
                <canvas id="throttle-gauge" width="496.2" height="496.2"></canvas>
            </div>
        </div>
        
        <!-- Text image overlays -->
        <div class="layer overlay-images-layer">
            <!-- Throttle/Brake text overlay -->
            <img src="/images/speedometer/Text.png" alt="Text Overlay" class="text-overlay">
            
            <!-- Speed units image overlay - switches between KMH/MPH -->
            <img id="kmh-layer" src="/images/speedometer/KMH.png" alt="Units Overlay" class="units-overlay">
        </div>
        
        <!-- Text and values layer -->
        <div class="layer text-layer">
            <!-- Speed value -->
            <div id="speed-value" class="speed-value">0</div>
            
            <!-- Speed units -->
            <div id="speed-units" class="speed-units">KMH</div>
            
            <!-- RPM value -->
            <div id="rpm-value" class="rpm-value">0</div>
            
            <!-- RPM label -->
            <div class="rpm-label">RPM</div>
            
            <!-- DRS container -->
            <div class="drs-container">
                <img src="/images/speedometer/drs.png" alt="DRS" class="drs-image">
                <div id="drs-label" class="drs-label">DRS</div>
            </div>
            
            <!-- Gear label -->
            <div class="gear-label">GEAR</div>
            
            <!-- Gear value -->
            <div id="gear-value" class="gear-value">N</div>
        </div>
    </div>
    <script>
        const socket = io();
        socket.emit('identify', 'Speedometer');
        
        const overlayContainer = document.querySelector('.overlay-container');
        
        // Handle overlay visibility from controller with animation
        socket.on('overlay_config', (config) => {
            if (config.overlays && config.overlays['speedometer']) {
                if (config.overlays['speedometer'].visible) {
                    overlayContainer.classList.add('visible');
                } else {
                    overlayContainer.classList.remove('visible');
                }
            }
        });
        
        const throttleCanvas = document.getElementById('throttle-gauge');
        const throttleCtx = throttleCanvas.getContext('2d');
        const brakeCanvas = document.getElementById('brake-gauge');
        const brakeCtx = brakeCanvas.getContext('2d');
        const speedCanvas = document.getElementById('speed-gauge');
        const speedCtx = speedCanvas.getContext('2d');
        let throttleAngle = 0; // Start at 0 throttle (-237°)
        let brakeAngle = 0; // Start at 0 brake (57°)
        let speedAngle = 0; // Start at 0 speed (-237°)
        
        // Load gauge images for canvas drawing
        const throttleImage = new Image();
        throttleImage.src = '/images/speedometer/Throttle_1.png';
        const brakeImage = new Image();
        brakeImage.src = '/images/speedometer/Brake_1.png';
        const speedImage = new Image();
        speedImage.src = '/images/speedometer/Speed_1.png';
        
        const kmhLayer = document.getElementById('kmh-layer');
        const drsLabel = document.getElementById('drs-label');
        const drsImage = document.querySelector('.drs-image');
        const gearValue = document.getElementById('gear-value');
        const rpmValue = document.getElementById('rpm-value');
        const speedValue = document.getElementById('speed-value');
        const speedUnits = document.getElementById('speed-units');
        let isMph = false; // Default to false until Session packet is received
        let currentDrsDisplayState = 0; // Track current DRS display state: 0=unavailable, 1=available, 2=active

        // Initialize DRS blink animation once
        const drsBlinkAnimation = anime({
            targets: drsImage,
            opacity: [1, 0, 1], // From 100% to 0% to 100%
            duration: 950, // Total cycle time (0.5s per transition approximated)
            easing: 'easeInOutQuad', // Smooth transition
            loop: true, // Continuous blink while drs2 is active
            autoplay: false // Start paused
        });

        function playDrsBlink() {
            drsBlinkAnimation.play();
        }

        function pauseAndResetDrsBlink() {
            drsBlinkAnimation.pause();
            anime.set(drsImage, { opacity: 1 }); // Force opacity to 1 immediately
        }

        function drawThrottleSweep(angle) {
            if (!throttleCtx) {
                console.error('Throttle canvas context not available');
                return;
            }
            throttleCtx.clearRect(0, 0, 496.2, 496.2);
            throttleCtx.save();

            // Apply the clip to include the full swept area
            throttleCtx.beginPath();
            const startAngle = -237 * Math.PI / 180; // Updated start angle
            const endAngle = startAngle + (angle * ((-46 - (-237)) * Math.PI / 180)); // Scale to -46°
            throttleCtx.moveTo(248.1, 248.1); // Center for 496.2px canvas
            throttleCtx.arc(248.1, 248.1, 248.1, startAngle, endAngle, false); // Clockwise sweep
            throttleCtx.clip();
            throttleCtx.drawImage(throttleImage, 0, 0, 496.2, 496.2); // Scaled image
            throttleCtx.restore();
        }

        function drawBrakeSweep(angle) {
            if (!brakeCtx) {
                console.error('Brake canvas context not available');
                return;
            }
            brakeCtx.clearRect(0, 0, 496.2, 496.2);
            brakeCtx.save();

            // Apply the clip to include the full swept area
            brakeCtx.beginPath();
            const startAngle = 57 * Math.PI / 180; // Updated start angle
            const endAngle = startAngle + (angle * ((-43 - 57) * Math.PI / 180)); // Scale to -43°, anti-clockwise
            brakeCtx.moveTo(248.1, 248.1); // Center for 496.2px canvas
            brakeCtx.arc(248.1, 248.1, 248.1, startAngle, endAngle, true); // Anti-clockwise sweep
            brakeCtx.clip();
            brakeCtx.drawImage(brakeImage, 0, 0, 496.2, 496.2); // Scaled image
            brakeCtx.restore();
        }

        function drawSpeedSweep(angle) {
            if (!speedCtx) {
                console.error('Speed canvas context not available');
                return;
            }
            speedCtx.clearRect(0, 0, 497, 496);
            speedCtx.save();

            // Apply the clip to include the full swept area
            const startAngle = -237 * Math.PI / 180; // Updated start angle
            const maxAngle = 57 * Math.PI / 180; // Maximum angle
            const endAngle = startAngle + (Math.min(angle, 1.0) * (maxAngle - startAngle)); // Cap at 1.0 (360 km/h)
            speedCtx.beginPath();
            speedCtx.moveTo(248.5, 248); // Center for 497x496 canvas
            speedCtx.arc(248.5, 248, 248, startAngle, endAngle, false); // Clockwise sweep
            speedCtx.clip();
            speedCtx.drawImage(speedImage, 0, 0, 497, 496); // Scaled image
            speedCtx.restore();
        }

        socket.on('f1_data', (data) => {
            if (data.m_header.m_packetId === 1) { // Session Packet
                const playerIndex = data.m_header.m_playerCarIndex;
                const speedUnitsLeadPlayer = data.m_speedUnitsLeadPlayer || 0;
                isMph = speedUnitsLeadPlayer === 0;
                speedUnits.textContent = isMph ? 'MPH' : 'KMH';
                kmhLayer.src = isMph ? '/images/speedometer/MPH.png' : '/images/speedometer/KMH.png';
            } else if (data.m_header.m_packetId === 6) { // Car Telemetry
                const playerIndex = data.m_header.m_playerCarIndex;
                const throttle = data.m_carTelemetryData[playerIndex].m_throttle; // 0.0 to 1.0
                const brake = data.m_carTelemetryData[playerIndex].m_brake; // 0.0 to 1.0
                const speed = data.m_carTelemetryData[playerIndex].m_speed; // 0 to 65535 km/h
                const gear = data.m_carTelemetryData[playerIndex].m_gear; // -1 to 8
                const rpm = data.m_carTelemetryData[playerIndex].m_engineRPM; // Engine RPM value

                // Update gear value
                if (gear === -1) {
                    gearValue.textContent = 'R';
                } else if (gear === 0) {
                    gearValue.textContent = 'N';
                } else if (gear >= 1 && gear <= 8) {
                    gearValue.textContent = gear;
                }

                // Update RPM value
                if (rpm !== undefined) {
                    rpmValue.textContent = rpm;
                }

                // Update speed value with unit conversion
                if (speed !== undefined) {
                    const displaySpeed = isMph ? Math.round(speed * 0.621371) : speed;
                    speedValue.textContent = displaySpeed;
                }

                const targetThrottleAngle = throttle; // 0 to 1 scales the 191° range
                const targetBrakeAngle = brake; // 0 to 1 scales the 100° range
                const targetSpeedAngle = Math.min(speed / 360, 1.0); // Cap at 360 km/h for gauge only
                anime({
                    targets: { angle: throttleAngle },
                    angle: targetThrottleAngle,
                    duration: 100, // ~16ms for 60Hz
                    easing: 'linear',
                    update: (anim) => {
                        throttleAngle = anim.animations[0].currentValue;
                        drawThrottleSweep(throttleAngle);
                    }
                });
                anime({
                    targets: { angle: brakeAngle },
                    angle: targetBrakeAngle,
                    duration: 100, // ~16ms for 60Hz
                    easing: 'linear',
                    update: (anim) => {
                        brakeAngle = anim.animations[0].currentValue;
                        drawBrakeSweep(brakeAngle);
                    }
                });
                anime({
                    targets: { angle: speedAngle },
                    angle: targetSpeedAngle,
                    duration: 100, // ~16ms for 60Hz
                    easing: 'linear',
                    update: (anim) => {
                        speedAngle = anim.animations[0].currentValue;
                        drawSpeedSweep(speedAngle);
                    }
                });
            }
        });

        // DRS State Management
        let drsState = { m_drs: null, m_drsAllowed: null, m_drsActivationDistance: null };

        socket.on('f1_data', (data) => {
            const playerIndex = data.m_header?.m_playerCarIndex || 0;

            if (data.m_header?.m_packetId === 6) { // Car Telemetry
                const telemetryData = data.m_carTelemetryData?.[playerIndex];
                if (telemetryData && telemetryData.hasOwnProperty('m_drs')) {
                    drsState.m_drs = telemetryData.m_drs;
                    
                    // Determine the desired DRS display state: 0=unavailable, 1=available, 2=active
                    let newDrsDisplayState;
                    if (drsState.m_drs === 1) {
                        newDrsDisplayState = 2; // Active
                    } else if (drsState.m_drsAllowed === 1) {
                        newDrsDisplayState = 1; // Available
                    } else {
                        newDrsDisplayState = 0; // Unavailable
                    }
                    
                    // Only update if state has changed
                    if (newDrsDisplayState !== currentDrsDisplayState) {
                        currentDrsDisplayState = newDrsDisplayState;
                        
                        if (currentDrsDisplayState === 2) {
                            // DRS Active - show drs1.png, stop blinking
                            drsImage.src = '/images/speedometer/drs1.png';
                            pauseAndResetDrsBlink();
                            drsLabel.style.textShadow = '3px 1px 0px black';
                        } else if (currentDrsDisplayState === 1) {
                            // DRS Available - show drs2.png, apply blinking
                            drsImage.src = '/images/speedometer/drs2.png';
                            playDrsBlink();
                            drsLabel.style.textShadow = '0px 0px 0px black';
                        } else {
                            // DRS Unavailable - show drs.png, stop blinking
                            drsImage.src = '/images/speedometer/drs.png';
                            pauseAndResetDrsBlink();
                            drsLabel.style.textShadow = '0px 0px 0px black';
                        }
                    } else {
                        // State hasn't changed, just update text shadow for active state
                        if (drsState.m_drs === 1) {
                            drsLabel.style.textShadow = '3px 1px 0px black';
                        } else {
                            drsLabel.style.textShadow = '0px 0px 0px black';
                        }
                    }
                }
            } else if (data.m_header?.m_packetId === 7) { // Car Status
                const statusData = data.m_carStatusData?.[playerIndex];
                if (statusData) {
                    drsState.m_drsAllowed = statusData.m_drsAllowed || null;
                    drsState.m_drsActivationDistance = statusData.m_drsActivationDistance || null;
                    
                    // Determine the desired DRS display state: 0=unavailable, 1=available, 2=active
                    let newDrsDisplayState;
                    if (drsState.m_drs === 1) {
                        newDrsDisplayState = 2; // Active
                    } else if (drsState.m_drsAllowed === 1) {
                        newDrsDisplayState = 1; // Available
                    } else {
                        newDrsDisplayState = 0; // Unavailable
                    }
                    
                    // Only update if state has changed and DRS is not currently active
                    if (newDrsDisplayState !== currentDrsDisplayState && drsState.m_drs !== 1) {
                        currentDrsDisplayState = newDrsDisplayState;
                        
                        if (currentDrsDisplayState === 1) {
                            // DRS Available - show drs2.png, apply blinking
                            drsImage.src = '/images/speedometer/drs2.png';
                            playDrsBlink();
                        } else {
                            // DRS Unavailable - show drs.png, stop blinking
                            drsImage.src = '/images/speedometer/drs.png';
                            pauseAndResetDrsBlink();
                        }
                    }
                }
            }

            // Update DRS text color, default to gray unless any value is non-zero
            const drs = drsState.m_drs === null ? 0 : drsState.m_drs;
            const drsAllowed = drsState.m_drsAllowed === null ? 0 : drsState.m_drsAllowed;
            const drsActivationDistance = drsState.m_drsActivationDistance === null ? 0 : drsState.m_drsActivationDistance;
            if (drs === 0 && drsAllowed === 0 && drsActivationDistance === 0) {
                drsLabel.style.color = 'gray';
            } else {
                drsLabel.style.color = 'white';
            }
        });

        // Initial draw and DRS default color
        drawThrottleSweep(throttleAngle);
        drawBrakeSweep(brakeAngle);
        drawSpeedSweep(speedAngle);
        drsLabel.style.color = 'gray'; // Set default DRS text color to gray
        speedUnits.textContent = 'KMH'; // Default to KMH
        kmhLayer.src = '/images/speedometer/KMH.png'; // Default to KMH image
    </script>
</body>
</html>