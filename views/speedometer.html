<!DOCTYPE html>
<html>
<head>
    <title>F1 Speedometer Overlay</title>
    <link rel="stylesheet" href="/fonts.css">
    <link rel="stylesheet" href="/styles-speedometer.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>
<body>
    <div class="overlay-container">
        <!-- Background layer -->
        <div class="layer background-layer">
            <img id="background-image" src="/images/speedometer/F1TV/F1TV_BG.png" alt="Background">
        </div>
        
        <!-- Value background layer -->
        <div class="layer gauge-layer">
            <img id="gauge-background-image" src="/images/speedometer/F1TV/F1TV_ValueBG.png" alt="Gauge Background">
        </div>
        
        <!-- Gauge canvases layer -->
        <div class="layer gauges-layer">
            <!-- Speed gauge -->
            <div class="dial-container speed-dial">
                <canvas id="speed-gauge" width="497" height="496"></canvas>
            </div>
            <!-- Brake gauge -->
            <div class="dial-container brake-dial">
                <canvas id="brake-gauge" width="496.2" height="496.2"></canvas>
            </div>
            <!-- Throttle gauge -->
            <div class="dial-container throttle-dial">
                <canvas id="throttle-gauge" width="496.2" height="496.2"></canvas>
            </div>
        </div>
        
        <!-- Text image overlays -->
        <div class="layer overlay-images-layer">
            <!-- Throttle/Brake text overlay -->
            <img src="/images/speedometer/Text.png" alt="Text Overlay" class="text-overlay">
            
            <!-- Speed units image overlay - switches between KMH/MPH -->
            <img id="kmh-layer" src="/images/speedometer/KMH.png" alt="Units Overlay" class="units-overlay">
        </div>
        
        <!-- Text and values layer -->
        <div class="layer text-layer">
            <!-- Speed value -->
            <div id="speed-value" class="speed-value">0</div>
            
            <!-- Speed units -->
            <div id="speed-units" class="speed-units">KMH</div>
            
            <!-- RPM value -->
            <div id="rpm-value" class="rpm-value">0</div>
            
            <!-- RPM label -->
            <div class="rpm-label">RPM</div>
            
            <!-- DRS container -->
            <div class="drs-container">
                <div class="drs-rectangle"></div>
                <img src="/images/speedometer/F1TV/drs.png" alt="DRS" class="drs-image">
                <div id="drs-label" class="drs-label">DRS</div>
            </div>
            
            <!-- Gear label -->
            <div class="gear-label">GEAR</div>
            
            <!-- Gear value -->
            <div id="gear-value" class="gear-value">N</div>
        </div>
    </div>
    <script>
        const socket = io();
        socket.emit('identify', 'Speedometer');
        
        const overlayContainer = document.querySelector('.overlay-container');
        
        // Store current config
        let currentConfig = {
            designMode: 'f1tv',
            unitsMode: 'automatic'
        };
        
        // Handle overlay visibility and config updates from controller
        socket.on('overlay_config', (config) => {
            if (config.overlays && config.overlays['speedometer']) {
                const speedometerConfig = config.overlays['speedometer'];
                
                // Handle visibility
                if (speedometerConfig.visible) {
                    overlayContainer.classList.add('visible');
                } else {
                    overlayContainer.classList.remove('visible');
                }
                
                // Check if design mode changed
                const newDesignMode = speedometerConfig.designMode || 'f1tv';
                if (newDesignMode !== currentConfig.designMode) {
                    currentConfig.designMode = newDesignMode;
                    applyDesignMode(newDesignMode);
                }
                
                // Update units mode
                currentConfig.unitsMode = speedometerConfig.unitsMode || 'automatic';
            }
        });
        
        const throttleCanvas = document.getElementById('throttle-gauge');
        const throttleCtx = throttleCanvas.getContext('2d');
        const brakeCanvas = document.getElementById('brake-gauge');
        const brakeCtx = brakeCanvas.getContext('2d');
        const speedCanvas = document.getElementById('speed-gauge');
        const speedCtx = speedCanvas.getContext('2d');
        let throttleAngle = 0; // Start at 0 throttle (-237°)
        let brakeAngle = 0; // Start at 0 brake (57°)
        let speedAngle = 0; // Start at 0 speed (-237°)
        
        // Get references to layer images
        const backgroundImage = document.getElementById('background-image');
        const gaugeBackgroundImage = document.getElementById('gauge-background-image');
        
        // Load gauge images for canvas drawing
        const throttleImage = new Image();
        const brakeImage = new Image();
        const speedImage = new Image();
        
        // Function to apply design mode
        function applyDesignMode(designMode) {
            if (designMode === 'multiviewer') {
                // Multiviewer design
                backgroundImage.src = '/images/speedometer/Multiviewer/MV BG.png';
                gaugeBackgroundImage.src = '/images/speedometer/Multiviewer/MV ValueBG.png';
                throttleImage.src = '/images/speedometer/Multiviewer/Throttle.png';
                brakeImage.src = '/images/speedometer/Multiviewer/Brake.png';
                speedImage.src = '/images/speedometer/Multiviewer/Speed.png';
                
                // Resize canvases for Multiviewer (500x500)
                throttleCanvas.width = 500;
                throttleCanvas.height = 500;
                brakeCanvas.width = 500;
                brakeCanvas.height = 500;
                speedCanvas.width = 500;
                speedCanvas.height = 500;
                
                // Apply Multiviewer CSS class
                overlayContainer.classList.add('multiviewer-mode');
                overlayContainer.classList.remove('f1tv-mode');
            } else {
                // F1TV design (default)
                backgroundImage.src = '/images/speedometer/F1TV/F1TV_BG.png';
                gaugeBackgroundImage.src = '/images/speedometer/F1TV/F1TV_ValueBG.png';
                throttleImage.src = '/images/speedometer/F1TV/Throttle.png';
                brakeImage.src = '/images/speedometer/F1TV/Brake.png';
                speedImage.src = '/images/speedometer/F1TV/Speed.png';
                
                // Resize canvases for F1TV
                throttleCanvas.width = 496.2;
                throttleCanvas.height = 496.2;
                brakeCanvas.width = 496.2;
                brakeCanvas.height = 496.2;
                speedCanvas.width = 497;
                speedCanvas.height = 496;
                
                // Apply F1TV CSS class
                overlayContainer.classList.add('f1tv-mode');
                overlayContainer.classList.remove('multiviewer-mode');
            }
            
            // Redraw gauges with new images once they're loaded
            Promise.all([
                new Promise(resolve => throttleImage.onload = resolve),
                new Promise(resolve => brakeImage.onload = resolve),
                new Promise(resolve => speedImage.onload = resolve)
            ]).then(() => {
                drawThrottleSweep(throttleAngle);
                drawBrakeSweep(brakeAngle);
                drawSpeedSweep(speedAngle);
            }).catch(error => {
                console.error('Failed to load gauge images:', error);
            });
        }
        
        // Initialize with default F1TV design
        applyDesignMode('f1tv');
        
        const kmhLayer = document.getElementById('kmh-layer');
        const drsLabel = document.getElementById('drs-label');
        const drsImage = document.querySelector('.drs-image');
        const drsRectangle = document.querySelector('.drs-rectangle');
        const gearValue = document.getElementById('gear-value');
        const rpmValue = document.getElementById('rpm-value');
        const speedValue = document.getElementById('speed-value');
        const speedUnits = document.getElementById('speed-units');
        let isMph = false; // Default to false until Session packet is received
        let currentDrsDisplayState = 0; // Track current DRS display state: 0=unavailable, 1=available, 2=active

        // Initialize DRS blink animation once
        const drsBlinkAnimation = anime({
            targets: [drsImage, drsRectangle],
            opacity: [1, 0, 1], // From 100% to 0% to 100%
            duration: 950, // Total cycle time (0.5s per transition approximated)
            easing: 'easeInOutQuad', // Smooth transition
            loop: true, // Continuous blink while drs2 is active
            autoplay: false // Start paused
        });

        function playDrsBlink() {
            drsBlinkAnimation.play();
        }

        function pauseAndResetDrsBlink() {
            drsBlinkAnimation.pause();
            anime.set([drsImage, drsRectangle], { opacity: 1 }); // Force opacity to 1 immediately
        }

        // DRS State Management
        let drsState = { m_drs: null, m_drsAllowed: null, m_drsActivationDistance: null };

        // Helper function to determine DRS state
        function determineDrsState() {
            if (drsState.m_drs === 1) return 2; // Active
            if (drsState.m_drsAllowed === 1) return 1; // Available
            return 0; // Unavailable
        }

        // Function to update DRS display based on design mode and state
        function updateDrsDisplay(state) {
            const isMultiviewer = currentConfig.designMode === 'multiviewer';
            
            // Clean up all DRS rectangle classes first
            drsRectangle.classList.remove('drs-unavailable', 'drs-available', 'drs-active');
            
            if (isMultiviewer) {
                // Multiviewer mode: use rectangle with CSS classes
                
                if (state === 2) {
                    // DRS Active - green background, stop blinking
                    drsRectangle.classList.add('drs-active');
                    pauseAndResetDrsBlink();
                    drsLabel.style.textShadow = '3px 1px 0px black';
                } else if (state === 1) {
                    // DRS Available - white border, apply blinking
                    drsRectangle.classList.add('drs-available');
                    playDrsBlink();
                    drsLabel.style.textShadow = '0px 0px 0px black';
                } else {
                    // DRS Unavailable - no styling, stop blinking
                    drsRectangle.classList.add('drs-unavailable');
                    pauseAndResetDrsBlink();
                    drsLabel.style.textShadow = '0px 0px 0px black';
                }
            } else {
                // F1TV mode: use images with blinking
                if (state === 2) {
                    // DRS Active - show drs1.png, stop blinking
                    drsImage.src = '/images/speedometer/F1TV/drs1.png';
                    pauseAndResetDrsBlink();
                    drsLabel.style.textShadow = '3px 1px 0px black';
                } else if (state === 1) {
                    // DRS Available - show drs2.png, apply blinking
                    drsImage.src = '/images/speedometer/F1TV/drs2.png';
                    playDrsBlink();
                    drsLabel.style.textShadow = '0px 0px 0px black';
                } else {
                    // DRS Unavailable - show drs.png, stop blinking
                    drsImage.src = '/images/speedometer/F1TV/drs.png';
                    pauseAndResetDrsBlink();
                    drsLabel.style.textShadow = '0px 0px 0px black';
                }
            }
        }

        function drawThrottleSweep(angle) {
            if (!throttleCtx) {
                console.error('Throttle canvas context not available');
                return;
            }
            const w = throttleCanvas.width;
            const h = throttleCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(centerX, centerY);
            
            throttleCtx.clearRect(0, 0, w, h);
            throttleCtx.save();

            // Apply the clip to include the full swept area
            throttleCtx.beginPath();
            const startAngle = -238 * Math.PI / 180;
            // Adjust target angle based on design mode: F1TV uses -45°, Multiviewer uses -50°
            const targetAngle = currentConfig.designMode === 'multiviewer' ? -50 : -45;
            const endAngle = startAngle + (angle * ((targetAngle - (-238)) * Math.PI / 180));
            throttleCtx.moveTo(centerX, centerY);
            throttleCtx.arc(centerX, centerY, radius, startAngle, endAngle, false); // Clockwise sweep
            throttleCtx.clip();
            throttleCtx.drawImage(throttleImage, 0, 0, w, h);
            throttleCtx.restore();
        }

        function drawBrakeSweep(angle) {
            if (!brakeCtx) {
                console.error('Brake canvas context not available');
                return;
            }
            const w = brakeCanvas.width;
            const h = brakeCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(centerX, centerY);
            
            brakeCtx.clearRect(0, 0, w, h);
            brakeCtx.save();

            // Apply the clip to include the full swept area
            brakeCtx.beginPath();
            const startAngle = 58 * Math.PI / 180;
            // Adjust target angle based on design mode: F1TV uses -44°, Multiviewer uses -46°
            const targetAngle = currentConfig.designMode === 'multiviewer' ? -46 : -44;
            const endAngle = startAngle + (angle * ((targetAngle - 58) * Math.PI / 180));
            brakeCtx.moveTo(centerX, centerY);
            brakeCtx.arc(centerX, centerY, radius, startAngle, endAngle, true); // Anti-clockwise sweep
            brakeCtx.clip();
            brakeCtx.drawImage(brakeImage, 0, 0, w, h);
            brakeCtx.restore();
        }

        function drawSpeedSweep(angle) {
            if (!speedCtx) {
                console.error('Speed canvas context not available');
                return;
            }
            const w = speedCanvas.width;
            const h = speedCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(centerX, centerY);
            
            speedCtx.clearRect(0, 0, w, h);
            speedCtx.save();

            // Apply the clip to include the full swept area
            const startAngle = -238 * Math.PI / 180; // Updated start angle to match throttle start angle
            const maxAngle = 58 * Math.PI / 180; // Maximum angle
            const endAngle = startAngle + (Math.min(angle, 1.0) * (maxAngle - startAngle)); // Cap at 1.0 (360 km/h)
            speedCtx.beginPath();
            speedCtx.moveTo(centerX, centerY);
            speedCtx.arc(centerX, centerY, radius, startAngle, endAngle, false); // Clockwise sweep
            speedCtx.clip();
            speedCtx.drawImage(speedImage, 0, 0, w, h);
            speedCtx.restore();
        }

        socket.on('f1_data', (data) => {
            const playerIndex = data.m_header?.m_playerCarIndex || 0;
            
            if (data.m_header.m_packetId === 1) { // Session Packet
                const speedUnitsLeadPlayer = data.m_speedUnitsLeadPlayer || 0;
                
                // Apply units mode override
                if (currentConfig.unitsMode === 'kmh') {
                    isMph = false;
                } else if (currentConfig.unitsMode === 'mph') {
                    isMph = true;
                } else {
                    // Automatic mode - use game data
                    isMph = speedUnitsLeadPlayer === 0;
                }
                
                speedUnits.textContent = isMph ? 'MPH' : 'KMH';
                kmhLayer.src = isMph ? '/images/speedometer/MPH.png' : '/images/speedometer/KMH.png';
            } else if (data.m_header.m_packetId === 6) { // Car Telemetry
                const playerIndex = data.m_header.m_playerCarIndex;
                const throttle = data.m_carTelemetryData[playerIndex].m_throttle; // 0.0 to 1.0
                const brake = data.m_carTelemetryData[playerIndex].m_brake; // 0.0 to 1.0
                const speed = data.m_carTelemetryData[playerIndex].m_speed; // 0 to 65535 km/h
                const gear = data.m_carTelemetryData[playerIndex].m_gear; // -1 to 8
                const rpm = data.m_carTelemetryData[playerIndex].m_engineRPM; // Engine RPM value

                // Update gear value
                if (gear === -1) {
                    gearValue.textContent = 'R';
                } else if (gear === 0) {
                    gearValue.textContent = 'N';
                } else if (gear >= 1 && gear <= 8) {
                    gearValue.textContent = gear;
                }

                // Update RPM value
                if (rpm !== undefined) {
                    rpmValue.textContent = rpm;
                }

                // Update speed value with unit conversion
                if (speed !== undefined) {
                    const displaySpeed = isMph ? Math.round(speed * 0.621371) : speed;
                    speedValue.textContent = displaySpeed;
                }

                const targetThrottleAngle = throttle; // 0 to 1 scales the 191° range
                const targetBrakeAngle = brake; // 0 to 1 scales the 100° range
                const targetSpeedAngle = Math.min(speed / 360, 1.0); // Cap at 360 km/h for gauge only
                anime({
                    targets: { angle: throttleAngle },
                    angle: targetThrottleAngle,
                    duration: 100, // ~16ms for 60Hz
                    easing: 'linear',
                    update: (anim) => {
                        throttleAngle = anim.animations[0].currentValue;
                        drawThrottleSweep(throttleAngle);
                    }
                });
                anime({
                    targets: { angle: brakeAngle },
                    angle: targetBrakeAngle,
                    duration: 100, // ~16ms for 60Hz
                    easing: 'linear',
                    update: (anim) => {
                        brakeAngle = anim.animations[0].currentValue;
                        drawBrakeSweep(brakeAngle);
                    }
                });
                anime({
                    targets: { angle: speedAngle },
                    angle: targetSpeedAngle,
                    duration: 100, // ~16ms for 60Hz
                    easing: 'linear',
                    update: (anim) => {
                        speedAngle = anim.animations[0].currentValue;
                        drawSpeedSweep(speedAngle);
                    }
                });
                
                // Handle DRS state from telemetry
                const telemetryData = data.m_carTelemetryData?.[playerIndex];
                if (telemetryData && telemetryData.hasOwnProperty('m_drs')) {
                    drsState.m_drs = telemetryData.m_drs;
                    
                    const newDrsDisplayState = determineDrsState();
                    
                    // Only update if state has changed
                    if (newDrsDisplayState !== currentDrsDisplayState) {
                        currentDrsDisplayState = newDrsDisplayState;
                        updateDrsDisplay(currentDrsDisplayState);
                    } else {
                        // State hasn't changed, just update text shadow for active state (F1TV mode only)
                        if (drsState.m_drs === 1 && currentConfig.designMode === 'f1tv') {
                            drsLabel.style.textShadow = '3px 1px 0px black';
                        }
                    }
                }
            } else if (data.m_header?.m_packetId === 7) { // Car Status
                const statusData = data.m_carStatusData?.[playerIndex];
                if (statusData) {
                    drsState.m_drsAllowed = statusData.m_drsAllowed || null;
                    drsState.m_drsActivationDistance = statusData.m_drsActivationDistance || null;
                    
                    const newDrsDisplayState = determineDrsState();
                    
                    // Only update if state has changed and DRS is not currently active
                    if (newDrsDisplayState !== currentDrsDisplayState && drsState.m_drs !== 1) {
                        currentDrsDisplayState = newDrsDisplayState;
                        updateDrsDisplay(currentDrsDisplayState);
                    }
                }
            }
            
            // Update DRS text color, default to gray unless any value is non-zero
            const drs = drsState.m_drs === null ? 0 : drsState.m_drs;
            const drsAllowed = drsState.m_drsAllowed === null ? 0 : drsState.m_drsAllowed;
            const drsActivationDistance = drsState.m_drsActivationDistance === null ? 0 : drsState.m_drsActivationDistance;
            if (drs === 0 && drsAllowed === 0 && drsActivationDistance === 0) {
                drsLabel.style.color = 'gray';
            } else {
                drsLabel.style.color = 'white';
            }
        });

        // Initial draw and DRS default color
        drawThrottleSweep(throttleAngle);
        drawBrakeSweep(brakeAngle);
        drawSpeedSweep(speedAngle);
        drsLabel.style.color = 'gray'; // Set default DRS text color to gray
        speedUnits.textContent = 'KMH'; // Default to KMH
        kmhLayer.src = '/images/speedometer/KMH.png'; // Default to KMH image
    </script>
</body>
</html>