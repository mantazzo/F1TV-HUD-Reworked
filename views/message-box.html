<!DOCTYPE html>
<html>
<head>
    <title>F1 Message Box Overlay</title>
    <link rel="stylesheet" href="/fonts.css">
    <link rel="stylesheet" href="/styles-message-box.css">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/textfit@2.4.0/textFit.min.js"></script>
</head>
<body>
    <!-- Main overlay container -->
    <div class="message-box-container">
        
        <!-- Top stripe -->
        <div class="top-stripe">
            <!-- Base white rectangle -->
            <div class="stripe-base"></div>
            
            <!-- Diagonal stripes layer (generated by JS) -->
            <div class="diagonal-stripes-layer" id="diagonalStripesLayer"></div>
            
            <!-- Blur effect -->
            <div class="stripe-blur"></div>
            
            <!-- First gradient -->
            <img src="/images/message-box/Gradient.png" class="stripe-gradient stripe-gradient-1" alt="">
            <!-- Second gradient -->
            <img src="/images/message-box/Gradient.png" class="stripe-gradient stripe-gradient-2" alt="">
        </div>
        
        <!-- Main penalties container -->
        <div class="penalties-container">
            
            <!-- Blue rectangle background -->
            <div class="blue-background"></div>
            
            <!-- White nameplate with diagonal stripes -->
            <div class="nameplate-section">
                <!-- White background -->
                <div class="nameplate-background"></div>
                
                <!-- Diagonal stripes layer (generated by JS) -->
                <div class="nameplate-stripes-layer" id="nameplateStripesLayer"></div>
            </div>
            
            <!-- FIA logo section -->
            <div class="fia-logo-section">
                <div class="fia-logo">f</div>
            </div>
            
            <!-- Penalty popup layer -->
            <div class="penalty-popup-layer">
                <!-- Blue background for penalty message -->
                <div class="penalty-background">
                    
                    <!-- White bordered box for PENALTY text -->
                    <div class="penalty-box">
                        <!-- PENALTY text -->
                        <div class="penalty-text">PENALTY</div>
                    </div>
                    
                    <!-- Time penalty layer -->
                    <div class="time-penalty-layer">
                        <!-- Penalty value (e.g., +3, +5) -->
                        <div class="penalty-value">+3</div>
                        
                        <!-- SECONDS text -->
                        <div class="penalty-seconds">SECONDS</div>
                    </div>
                    
                </div>
                <!-- Name layer -->
                <div class="name-layer">
                    <!-- First name -->
                    <div class="driver-first-name">MAX</div>
                    
                    <!-- Last name -->
                    <div class="driver-last-name">VERSTAPPEN</div>
                </div>
                
            </div>
            
            <!-- Generic message box layer -->
            <div class="message-box-layer">
                <div class="message-text">
                    <div><span class="message-prefix">FIA STEWARDS:</span> 10 SECONDS STOP/GO TIME PENALTY FOR CAR 1 (VER) - CAUSING A COLLISION</div>
                </div>
            </div>
            
            <!-- Transition lines -->
            <div class="transition-lines-layer">
                <div class="transition-lines-container">
                    <div class="transition-line transition-line-1"></div>
                    <div class="transition-line transition-line-2"></div>
                    <div class="transition-line transition-line-3"></div>
                    <div class="transition-line transition-line-4"></div>
                    <div class="transition-line transition-line-5"></div>
                </div>
            </div>
            
        </div>
        
    </div>

    <!-- Formation Lap Box (separate from main container) -->
    <div class="formation-lap-container">
        <!-- Formation Lap Box Background -->
        <div class="formation-lap-box">
            <div class="formation-lap-text">FORMATION LAP</div>
            <div class="formation-lap-red-line"></div>
        </div>
        
        <!-- Formation Lap Stroke (top stripe) -->
        <div class="formation-lap-stroke">
            <div class="formation-stroke-base"></div>
            <div class="formation-stroke-diagonal-layer" id="formationStrokeDiagonalLayer"></div>
            <div class="formation-stroke-blur"></div>
            <img src="/images/message-box/Gradient.png" class="formation-stroke-gradient formation-stroke-gradient-1" alt="">
            <img src="/images/message-box/Gradient.png" class="formation-stroke-gradient formation-stroke-gradient-2" alt="">
        </div>
    </div>
    
    <script>
        const socket = io();
        
        // Generate diagonal stripes on page load
        function generateDiagonalStripes() {
            const layer = document.getElementById('diagonalStripesLayer');
            
            // item_1_1_3r0: First stripe (no wrapper)
            const firstStripe = document.createElement('div');
            firstStripe.className = 'diagonal-stripe';
            firstStripe.id = 'stripe-0';
            layer.appendChild(firstStripe);
            
            // item_1_1_3r1 to item_1_1_3r152: Stripes with wrappers
            for (let i = 1; i <= 152; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'layer-repetition';
                wrapper.style.left = (i * 9) + 'px';
                
                const stripe = document.createElement('div');
                stripe.className = 'diagonal-stripe';
                stripe.id = `stripe-${i}`;
                
                wrapper.appendChild(stripe);
                layer.appendChild(wrapper);
            }
            
            console.log('[MessageBox] Generated 153 diagonal stripes for top stripe');
        }
        
        // Generate nameplate diagonal stripes
        function generateNameplateStripes() {
            const layer = document.getElementById('nameplateStripesLayer');
            
            // First stripe (no wrapper)
            const firstStripe = document.createElement('div');
            firstStripe.className = 'nameplate-diagonal-stripe';
            firstStripe.id = 'nameplate-stripe-0';
            layer.appendChild(firstStripe);
            
            // 14 more stripes with wrappers (56px spacing)
            for (let i = 1; i <= 14; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'nameplate-layer-repetition';
                wrapper.style.left = (i * 56) + 'px';
                
                const stripe = document.createElement('div');
                stripe.className = 'nameplate-diagonal-stripe';
                stripe.id = `nameplate-stripe-${i}`;
                
                wrapper.appendChild(stripe);
                layer.appendChild(wrapper);
            }
            
            console.log('[MessageBox] Generated 15 diagonal stripes for nameplate');
        }
        
        // Generate Formation Lap stroke diagonal stripes
        function generateFormationStrokeDiagonalStripes() {
            const layer = document.getElementById('formationStrokeDiagonalLayer');
            
            // First stripe (no wrapper)
            const firstStripe = document.createElement('div');
            firstStripe.className = 'formation-stroke-diagonal-stripe';
            firstStripe.id = 'formation-stroke-stripe-0';
            layer.appendChild(firstStripe);
            
            // Stripes with wrappers
            for (let i = 1; i <= 152; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'formation-stroke-layer-repetition';
                wrapper.style.left = (i * 9) + 'px';
                
                const stripe = document.createElement('div');
                stripe.className = 'formation-stroke-diagonal-stripe';
                stripe.id = `formation-stroke-stripe-${i}`;
                
                wrapper.appendChild(stripe);
                layer.appendChild(wrapper);
            }
            
            console.log('[MessageBox] Generated 153 diagonal stripes for Formation Lap stroke');
        }
        
        // Generate stripes immediately
        generateDiagonalStripes();
        generateNameplateStripes();
        generateFormationStrokeDiagonalStripes();
        
        // Identify to server
        socket.emit('identify', 'Message Box');
        
        // Get DOM elements
        const messageBoxContainer = document.querySelector('.message-box-container');
        const messageBoxLayer = document.querySelector('.message-box-layer');
        const messageText = document.querySelector('.message-text');
        const transitionLinesLayer = document.querySelector('.transition-lines-layer');
        const penaltyPopupLayer = document.querySelector('.penalty-popup-layer');
        const penaltyBox = document.querySelector('.penalty-box');
        const timePenaltyLayer = document.querySelector('.time-penalty-layer');
        const penaltyTextElement = document.querySelector('.penalty-text');
        const penaltyValueElement = document.querySelector('.penalty-value');
        const penaltySecondsElement = document.querySelector('.penalty-seconds');
        const driverFirstNameElement = document.querySelector('.driver-first-name');
        const driverLastNameElement = document.querySelector('.driver-last-name');
        
        // Animation state
        let hideTimeout = null;
        
        // Queue system
        let messageQueue = [];
        let isDisplaying = false;
        
        // Driver data storage
        let participantAbbreviations = {};
        let participantData = {};  // Store full participant data
        let aiDrivers = {};
        let customDrivers = [];
        let eventCodes = {};
        let penalties = [];
        let infringements = [];
        let teamNames = {};
        let formulaType = 0;
        
        // Listen for drivers data from server
        socket.on('drivers_data', (data) => {
            aiDrivers = data;
            console.log('[MessageBox] AI drivers updated from server:', Object.keys(aiDrivers).length, 'drivers');
        });
        
        // Listen for event codes from server
        socket.on('event_codes', (data) => {
            eventCodes = data;
            console.log('[MessageBox] Event codes received:', Object.keys(eventCodes).length, 'codes');
        });
        
        // Listen for penalties from server
        socket.on('penalties_data', (data) => {
            penalties = data;
            console.log('[MessageBox] Penalties received:', penalties.length, 'types');
        });
        
        // Listen for infringements from server
        socket.on('infringements_data', (data) => {
            infringements = data;
            console.log('[MessageBox] Infringements received:', infringements.length, 'types');
        });
        
        // Load JSON files (teams and custom drivers)
        async function loadJsonFiles() {
            try {
                const promises = [fetch('/data/DefaultTeams.json')];
                if (formulaType === 0) {
                    promises.push(fetch('/data/CustomF1Drivers.json'));
                } else if (formulaType === 2) {
                    promises.push(fetch('/data/CustomF2Drivers.json'));
                }
                const responses = await Promise.all(promises.map(p => p.catch(() => null)));
                teamNames = responses[0] ? await responses[0].json() : {};
                if (responses[1]) {
                    const customDriversData = await responses[1].json();
                    customDrivers = Array.isArray(customDriversData) ? customDriversData : [];
                }
                console.log('[MessageBox] Loaded team data and', customDrivers.length, 'custom drivers');
            } catch (error) {
                console.error('[MessageBox] Error loading JSON files:', error);
                teamNames = {};
                customDrivers = [];
            }
        }
        
        // Match custom driver based on participant data
        function matchCustomDriver(participant, showOnlineNames) {
            const raceNumber = participant.m_raceNumber;
            const name = participant.m_name;
            const teamId = participant.m_teamId;
            const team = teamNames[teamId] ? teamNames[teamId].ShortName : `Team_${teamId}`;

            // Priority 1: Exact name match (only if showOnlineNames is 1)
            // Skip name matching if showOnlineNames is 0 (player shows as "PLAYER")
            if (showOnlineNames === 1) {
                for (let driver of customDrivers) {
                    if (driver.MatchName && driver.MatchName.toUpperCase() === name.toUpperCase()) {
                        return driver;
                    }
                }
            }

            // Priority 2: Number + Team match
            for (let driver of customDrivers) {
                if (driver.RaceNumber && driver.Team && driver.RaceNumber === raceNumber && driver.Team === team) {
                    return driver;
                }
            }

            // Priority 3: Number only match
            for (let driver of customDrivers) {
                if (driver.RaceNumber && driver.RaceNumber === raceNumber) {
                    return driver;
                }
            }

            return null;
        }
        
        // Load JSON files on startup
        loadJsonFiles();
        
        // Listen for F1 data packets
        socket.on('f1_data', (data) => {
            const packetId = data.m_header ? data.m_header.m_packetId : -1;
            
            // Handle Participants packet (packet ID 4)
            if (packetId === 4) {
                participantAbbreviations = {};
                participantData = {};  // Reset participant data
                const numActiveCars = data.m_participants.length;
                
                for (let i = 0; i < numActiveCars; i++) {
                    const participant = data.m_participants[i];
                    const index = participant.m_participantIndex !== undefined ? participant.m_participantIndex : i;
                    const driverId = participant.m_driverId;
                    const showOnlineNames = participant.m_showOnlineNames;
                    const raceNumber = participant.m_raceNumber;
                    const teamId = participant.m_teamId;
                    
                    // Store full participant data
                    participantData[index] = participant;
                    
                    // Get abbreviation
                    if (driverId === 255) {
                        // Custom driver
                        const customDriver = matchCustomDriver(participant, showOnlineNames);
                        if (customDriver) {
                            participantAbbreviations[index] = customDriver.Abbreviation || customDriver.abbreviation || 'XXX';
                        } else {
                            // Fallback: Use team name
                            const team = teamNames[teamId];
                            if (team && team.ShortName) {
                                participantAbbreviations[index] = team.ShortName.substring(0, 3).toUpperCase();
                            } else {
                                participantAbbreviations[index] = 'XXX';
                            }
                        }
                    } else {
                        // AI driver
                        const aiDriver = aiDrivers[driverId];
                        if (aiDriver && aiDriver.abbreviation) {
                            participantAbbreviations[index] = aiDriver.abbreviation.toUpperCase();
                        } else {
                            // Fallback: Use team name
                            const team = teamNames[teamId];
                            if (team && team.ShortName) {
                                participantAbbreviations[index] = team.ShortName.substring(0, 3).toUpperCase();
                            } else {
                                participantAbbreviations[index] = 'XXX';
                            }
                        }
                    }
                }
                
                console.log('[MessageBox] Updated participant data for', numActiveCars, 'drivers');
                return;
            }
            
            // Handle Event packets (packet ID 3)
            if (packetId === 3) {
                const eventCode = data.m_eventStringCode;
                
                // Handle DRS Enabled event
                if (eventCode === eventCodes.DRSEnabled) {
                    queueMessage('message', {
                        prefix: 'RACE CONTROL:',
                        text: 'DRS ENABLED',
                        duration: 8000
                    });
                }
                
                // Handle DRS Disabled event
                if (eventCode === eventCodes.DRSDisabled) {
                    const eventDetails = data.m_eventDetails || {};
                    const reason = eventDetails.reason !== undefined ? eventDetails.reason : -1;
                    
                    // If reason is 0 (wet track/weather), show weather message
                    if (reason === 0) {
                        queueMessage('message', {
                            prefix: 'RACE CONTROL:',
                            text: 'DRS DISABLED DUE TO WEATHER',
                            duration: 8000
                        });
                    } else {
                        queueMessage('message', {
                            prefix: 'RACE CONTROL:',
                            text: 'DRS DISABLED',
                            duration: 8000
                        });
                    }
                }
                
                // Handle Red Flag event
                if (eventCode === eventCodes.RedFlag) {
                    queueMessage('message', {
                        prefix: 'RACE CONTROL:',
                        text: 'SESSION STOPPED - RED FLAG',
                        duration: 16000
                    });
                }
                
                // Handle Retirement event
                if (eventCode === eventCodes.Retirement) {
                    const eventDetails = data.m_eventDetails || {};
                    const vehicleIdx = eventDetails.vehicleIdx !== undefined ? eventDetails.vehicleIdx : -1;
                    const reason = eventDetails.reason !== undefined ? eventDetails.reason : -1;
                    
                    // Only show message for specific retirement reasons (1, 3, 6, 8)
                    if (vehicleIdx >= 0 && (reason === 1 || reason === 3 || reason === 6 || reason === 8)) {
                        const participant = participantData[vehicleIdx];
                        const raceNumber = participant ? participant.m_raceNumber : 0;
                        const abbreviation = participantAbbreviations[vehicleIdx] || null;
                        
                        // Build message: "CAR XX (ABC) HAS RETIRED"
                        let messageText = `CAR ${raceNumber}`;
                        if (abbreviation) {
                            messageText += ` (${abbreviation})`;
                        }
                        messageText += ' HAS RETIRED';
                        
                        // Add reason suffix
                        if (reason === 3) {
                            messageText += ' - TERMINAL DAMAGE';
                        } else if (reason === 6) {
                            messageText += ' - DISQUALIFIED';
                        } else if (reason === 8) {
                            messageText += ' - MECHANICAL FAILURE';
                        }
                        
                        queueMessage('message', {
                            prefix: 'RACE CONTROL:',
                            text: messageText,
                            duration: 8000
                        });
                        console.log('[MessageBox] Retirement - Car', raceNumber, abbreviation || '', 'Reason:', reason);
                    }
                }
                
                // Handle Safety Car event
                if (eventCode === eventCodes.SafetyCar) {
                    const eventDetails = data.m_eventDetails || {};
                    const safetyCarType = eventDetails.safetyCarType !== undefined ? eventDetails.safetyCarType : -1;
                    const eventType = eventDetails.eventType !== undefined ? eventDetails.eventType : -1;
                    
                    // Safety Car
                    if (safetyCarType === 1) {
                        if (eventType === 0) {
                            queueMessage('message', {
                                prefix: 'RACE CONTROL:',
                                text: 'SAFETY CAR DEPLOYED',
                                duration: 8000
                            });
                        } else if (eventType === 1) {
                            queueMessage('message', {
                                prefix: 'RACE CONTROL:',
                                text: 'SAFETY CAR IN THIS LAP',
                                duration: 8000
                            });
                        }
                    }
                    // Virtual Safety Car
                    else if (safetyCarType === 2) {
                        if (eventType === 0) {
                            queueMessage('message', {
                                prefix: 'RACE CONTROL:',
                                text: 'VSC DEPLOYED',
                                duration: 8000
                            });
                        } else if (eventType === 1) {
                            queueMessage('message', {
                                prefix: 'RACE CONTROL:',
                                text: 'VSC ENDING',
                                duration: 8000
                            });
                        }
                    }
                    // Formation Lap
                    else if (safetyCarType === 3) {
                        const formationLapContainer = document.querySelector('.formation-lap-container');
                        if (eventType === 0) {
                            // Formation lap starting - show container
                            if (formationLapContainer) {
                                formationLapContainer.style.opacity = '1';
                                console.log('[MessageBox] Formation lap started');
                            }
                        } else if (eventType === 3) {
                            // Formation lap ending - hide container
                            if (formationLapContainer) {
                                formationLapContainer.style.opacity = '0';
                                console.log('[MessageBox] Formation lap ended');
                            }
                        }
                    }
                }
                
                // Handle Penalty event
                if (eventCode === eventCodes.PenaltyIssued) {
                    const eventDetails = data.m_eventDetails || {};
                    const vehicleIdx = eventDetails.vehicleIdx !== undefined ? eventDetails.vehicleIdx : -1;
                    const otherVehicleIdx = eventDetails.otherVehicleIdx !== undefined ? eventDetails.otherVehicleIdx : 255;
                    const penaltyType = eventDetails.penaltyType !== undefined ? eventDetails.penaltyType : -1;
                    const infringementType = eventDetails.infringementType !== undefined ? eventDetails.infringementType : -1;
                    const time = eventDetails.time !== undefined ? eventDetails.time : 255;
                    const placesGained = eventDetails.placesGained !== undefined ? eventDetails.placesGained : 0;
                    
                    // Only handle specific penalty types: 0 (Drive through), 1 (Stop Go), 4 (Time penalty), 5 (Warning), 6 (Disqualified)
                    if (vehicleIdx >= 0 && (penaltyType === 0 || penaltyType === 1 || penaltyType === 4 || penaltyType === 5 || penaltyType === 6)) {
                        const participant = participantData[vehicleIdx];
                        const raceNumber = participant ? participant.m_raceNumber : 0;
                        const abbreviation = participantAbbreviations[vehicleIdx] || null;
                        
                        // Get penalty name and infringement text
                        const penaltyName = penalties[penaltyType] || 'PENALTY'; // Not really used, though...
                        const infringementText = getInfringementMessage(infringementType);
                        
                        let messageText = '';
                        
                        // Build message based on penalty type
                        if (penaltyType === 4) {
                            // Time penalty - show time if available
                            if (time !== 255) {
                                messageText = `${time} SECOND${time !== 1 ? 'S' : ''} TIME PENALTY FOR CAR ${raceNumber}`;
                            } else {
                                messageText = `TIME PENALTY FOR CAR ${raceNumber}`;
                            }
                        } else if (penaltyType === 5) {
                            // Warning
                            messageText = `WARNING FOR CAR ${raceNumber}`;
                        } else if (penaltyType === 6) {
                            // Disqualified
                            messageText = `CAR ${raceNumber}`;
                            if (abbreviation) {
                                messageText += ` (${abbreviation})`;
                            }
                            messageText += ' HAS BEEN DISQUALIFIED';
                        } else if (penaltyType === 1) {
                            // Stop-go - show time if available
                            if (time !== 255) {
                                messageText = `${time} SECOND${time !== 1 ? 'S' : ''} STOP/GO TIME PENALTY FOR CAR ${raceNumber}`;
                            } else {
                                messageText = `STOP/GO PENALTY FOR CAR ${raceNumber}`;
                            }
                        } else if (penaltyType === 0) {
                            // Drive through
                            messageText = `DRIVE THROUGH PENALTY FOR CAR ${raceNumber}`;
                        }
                        
                        // Add abbreviation for non-disqualification penalties
                        if (penaltyType !== 6 && abbreviation) {
                            messageText += ` (${abbreviation})`;
                        }
                        
                        // Add infringement reason
                        messageText += ` - ${infringementText}`;

                        // Add involved vehicle (if available)
                        if (otherVehicleIdx >= 0 && otherVehicleIdx !== 255) {
                            const otherParticipant = participantData[otherVehicleIdx];
                            const otherRaceNumber = otherParticipant ? otherParticipant.m_raceNumber : 0;
                            const otherAbbreviation = participantAbbreviations[otherVehicleIdx] || null;
                            messageText += ` WITH CAR ${otherRaceNumber} (${otherAbbreviation})`;
                        }

                        // Add positions gained (if applicable)
                        if (placesGained > 0) {
                            messageText += ` - GAINED ${placesGained} POSITION${placesGained !== 1 ? 'S' : ''}`;
                        }
                        
                        // Extract driver name data for penalty popup
                        let firstName = '';
                        let lastName = '';
                        if (participant) {
                            const driverId = participant.m_driverId;
                            
                            if (driverId === 255) {
                                // Custom driver
                                const customDriver = matchCustomDriver(participant, participant.m_showOnlineNames);
                                if (customDriver) {
                                    firstName = customDriver.FirstName || '';
                                    lastName = customDriver.LastName || customDriver.DisplayName || 'PLAYER';
                                } else {
                                    // Fallback to participant name
                                    const fullName = participant.m_name || 'PLAYER';
                                    const nameParts = fullName.split(' ');
                                    if (nameParts.length > 1) {
                                        firstName = nameParts[0];
                                        lastName = nameParts.slice(1).join(' ');
                                    } else {
                                        lastName = fullName;
                                    }
                                }
                            } else {
                                // AI driver
                                const aiDriver = aiDrivers[driverId];
                                if (aiDriver) {
                                    firstName = aiDriver.firstName || '';
                                    lastName = aiDriver.lastName || '';
                                }
                            }
                        }
                        
                        // Determine penalty text type for display
                        let penaltyTextType = 'PENALTY';
                        if (penaltyType === 5) {
                            penaltyTextType = 'WARNING';
                        }
                        
                        // Queue penalty popup (8 seconds popup + 8 seconds message)
                        queueMessage('penalty', {
                            time: time,
                            fullMessageText: messageText,
                            penaltyTextType: penaltyTextType,
                            firstName: firstName,
                            lastName: lastName
                        });
                        console.log('[MessageBox] Penalty - Car', raceNumber, abbreviation || '', 'Type:', penaltyName, 'Infringement:', infringementText);
                    }
                }
                
                // Handle Stop Go Served event
                if (eventCode === eventCodes.StopGoServed) {
                    const eventDetails = data.m_eventDetails || {};
                    const vehicleIdx = eventDetails.vehicleIdx !== undefined ? eventDetails.vehicleIdx : -1;
                    const stopTime = eventDetails.stopTime !== undefined ? eventDetails.stopTime : 0;
                    
                    if (vehicleIdx >= 0) {
                        const participant = participantData[vehicleIdx];
                        const raceNumber = participant ? participant.m_raceNumber : 0;
                        const abbreviation = participantAbbreviations[vehicleIdx] || null;
                        
                        // Build message: "PENALTY SERVED - X SECONDS STOP/GO TIME PENALTY FOR CAR XX (ABC)"
                        let messageText = `PENALTY SERVED - ${stopTime} SECOND${stopTime !== 1 ? 'S' : ''} STOP/GO TIME PENALTY FOR CAR ${raceNumber}`;
                        
                        if (abbreviation) {
                            messageText += ` (${abbreviation})`;
                        }
                        
                        queueMessage('message', {
                            prefix: 'FIA STEWARDS:',
                            text: messageText,
                            duration: 8000
                        });
                        console.log('[MessageBox] Stop Go Served - Car', raceNumber, abbreviation || '', 'Stop time:', stopTime);
                    }
                }
                
                // Handle Drive Through Served event
                if (eventCode === eventCodes.DriveThroughServed) {
                    const eventDetails = data.m_eventDetails || {};
                    const vehicleIdx = eventDetails.vehicleIdx !== undefined ? eventDetails.vehicleIdx : -1;
                    
                    if (vehicleIdx >= 0) {
                        const participant = participantData[vehicleIdx];
                        const raceNumber = participant ? participant.m_raceNumber : 0;
                        const abbreviation = participantAbbreviations[vehicleIdx] || null;
                        
                        // Build message: "PENALTY SERVED - DRIVE THROUGH PENALTY FOR CAR XX (ABC)"
                        let messageText = `PENALTY SERVED - DRIVE THROUGH PENALTY FOR CAR ${raceNumber}`;
                        
                        if (abbreviation) {
                            messageText += ` (${abbreviation})`;
                        }
                        
                        queueMessage('message', {
                            prefix: 'FIA STEWARDS:',
                            text: messageText,
                            duration: 8000
                        });
                        console.log('[MessageBox] Drive Through Served - Car', raceNumber, abbreviation || '');
                    }
                }
            }
        });
        
        // Function to get a cleaner infringement message
        function getInfringementMessage(infringementType) {
            if (!infringements || infringementType >= infringements.length) {
                return 'UNKNOWN INFRINGEMENT';
            }
            
            // Map similar infringements to consolidated messages (or rename some of them instead)
            const infringementMappings = {
                3: 'CAUSING A COLLISION',  // Big Collision
                4: 'CAUSING A COLLISION',  // Small Collision
                5: 'ILLEGAL OVERTAKE',     // Collision failed to hand back position single
                6: 'ILLEGAL OVERTAKE',     // Collision failed to hand back position multiple
                7: 'TRACK LIMITS',         // Corner cutting gained time
                8: 'ILLEGAL OVERTAKE',     // Corner cutting overtake single
                9: 'ILLEGAL OVERTAKE',     // Corner cutting overtake multiple
                17: 'SPEEDING IN THE PITLANE', // Pit lane speeding
                27: 'TRACK LIMITS',        // Corner cutting ran wide gained time minor
                28: 'TRACK LIMITS',        // Corner cutting ran wide gained time significant
                29: 'TRACK LIMITS',        // Corner cutting ran wide gained time extreme
                35: 'COLLISION WITH SC',   // Safety car to car collision
                36: 'ILLEGAL OVERTAKE',    // Safety car illegal overtake
                37: 'SPEEDING UNDER SC',   // Safety car exceeding allowed pace
                38: 'SPEEDING UNDER VSC',  // Virtual safety car exceeding allowed pace
                43: 'SAFETY CAR INFRINGEMENT', // Safety car falling too far back
                45: 'UNSERVED STOP/GO TIME PENALTY', // Unserved stop go penalty
            };
            
            // Return mapped message if exists, otherwise use original from array
            if (infringementMappings[infringementType]) {
                return infringementMappings[infringementType];
            }
            
            return infringements[infringementType].toUpperCase();
        }
        
        // Queue management functions
        function queueMessage(type, data) {
            const queueItem = { type, data };
            
            if (!isDisplaying) {
                // Nothing is displaying, show immediately
                isDisplaying = true;
                if (type === 'penalty') {
                    showPenaltyPopup(data.time, data.fullMessageText, data.penaltyTextType, data.firstName, data.lastName);
                } else if (type === 'message') {
                    showMessage(data.prefix, data.text, data.duration);
                }
            } else {
                // Something is displaying, add to queue
                messageQueue.push(queueItem);
            }
        }
        
        function processQueue() {
            if (messageQueue.length === 0) {
                // Queue is empty
                return;
            }
            
            // Get next item from queue
            const nextItem = messageQueue.shift();
            isDisplaying = true;
            
            if (nextItem.type === 'penalty') {
                showPenaltyPopup(nextItem.data.time, nextItem.data.fullMessageText, nextItem.data.penaltyTextType, nextItem.data.firstName, nextItem.data.lastName);
            } else if (nextItem.type === 'message') {
                showMessage(nextItem.data.prefix, nextItem.data.text, nextItem.data.duration);
            }
        }
        
        // Function to show penalty popup (two-phase display)
        function showPenaltyPopup(time, fullMessageText, penaltyTextType = 'PENALTY', firstName = '', lastName = '') {
            // Clear any existing timeout
            if (hideTimeout) {
                clearTimeout(hideTimeout);
            }
            
            // Set driver name
            if (driverFirstNameElement) {
                driverFirstNameElement.textContent = firstName.toUpperCase();
                textFit(driverFirstNameElement, {
                    minFontSize: 14,
                    maxFontSize: 27,
                    multiLine: false,
                    alignHoriz: true,
                    alignVert: false,
                    widthOnly: true
                });
            }
            if (driverLastNameElement) {
                driverLastNameElement.textContent = lastName.toUpperCase();
                textFit(driverLastNameElement, {
                    minFontSize: 14,
                    maxFontSize: 31,
                    multiLine: false,
                    alignHoriz: true,
                    alignVert: false,
                    widthOnly: true
                });
            }
            
            // Set penalty value if time is available
            if (time !== 255 && penaltyValueElement) {
                penaltyValueElement.textContent = `+${time}`;
                // Adjust position for 2-digit numbers
                if (time >= 10) {
                    penaltyValueElement.style.left = '14px';
                    penaltySecondsElement.style.left = '131px';
                } else {
                    penaltyValueElement.style.left = '-6px';
                    penaltySecondsElement.style.left = '111px';
                }
            }
            
            // First, show the message box container and transition lines
            messageBoxContainer.style.left = '0px';
            messageBoxContainer.style.width = '710px';
            messageBoxContainer.style.opacity = '1';
            
            if (transitionLinesLayer) {
                transitionLinesLayer.style.left = '710px';
                transitionLinesLayer.style.width = '710px';
                transitionLinesLayer.style.opacity = '0.6';
            }
            
            // Phase 1: Show penalty-popup-layer with penalty-box
            if (penaltyPopupLayer) {
                penaltyPopupLayer.style.opacity = '1';
            }
            if (penaltyBox) {
                penaltyBox.style.opacity = '1';
            }
            
            // Set penalty text based on passed type (WARNING or PENALTY)
            if (penaltyTextElement) {
                penaltyTextElement.textContent = penaltyTextType;
                penaltyTextElement.classList.add('blinking');
            }
            
            console.log('[MessageBox] Phase 1: Showing penalty popup with blinking text:', penaltyTextType);
            
            // After 4 seconds: Stop blinking and switch display
            setTimeout(() => {
                // Stop blinking
                if (penaltyTextElement) {
                    penaltyTextElement.classList.remove('blinking');
                }
                
                // If time penalty, show time-penalty-layer, otherwise keep penalty-box
                if (time !== 255 && timePenaltyLayer && penaltyBox) {
                    penaltyBox.style.opacity = '0';
                    timePenaltyLayer.style.opacity = '1';
                    console.log('[MessageBox] Phase 2: Showing time penalty layer');
                } else {
                    console.log('[MessageBox] Phase 2: Keeping penalty box (no time)');
                }
            }, 4000);
            
            // After 8 seconds: Hide penalty popup and show message layer
            setTimeout(() => {
                // Hide penalty popup
                if (penaltyPopupLayer) {
                    penaltyPopupLayer.style.opacity = '0';
                }
                if (penaltyBox) {
                    penaltyBox.style.opacity = '0';
                }
                if (timePenaltyLayer) {
                    timePenaltyLayer.style.opacity = '0';
                }
                
                console.log('[MessageBox] Phase 3: Showing message layer');
                
                // Show message layer (just the text, container is already visible)
                if (messageText) {
                    messageText.innerHTML = `<div><span class="message-prefix">FIA STEWARDS:</span> ${fullMessageText.toUpperCase()}</div>`;
                }
                messageBoxLayer.style.opacity = '1';
                
                // Hide everything after 8 more seconds and process queue
                hideTimeout = setTimeout(() => {
                    hideMessage();
                }, 8000);
            }, 8000);
        }
        
        // Function to display a message
        function showMessage(prefix, text, duration = 16000) {
            // Build message with prefix (if provided)
            if (prefix) {
                messageText.innerHTML = `<div><span class="message-prefix">${prefix.toUpperCase()}</span> ${text.toUpperCase()}</div>`;
            } else {
                messageText.innerHTML = `<div>${text.toUpperCase()}</div>`;
            }
            
            // Show message box layer
            messageBoxLayer.style.opacity = '1';
            
            // Clear any existing hide timeout
            if (hideTimeout) {
                clearTimeout(hideTimeout);
            }
            
            // Trigger animation - slide in from right
            messageBoxContainer.style.left = '0px';
            messageBoxContainer.style.width = '710px';
            messageBoxContainer.style.opacity = '1';
            
            // Animate transition lines
            if (transitionLinesLayer) {
                transitionLinesLayer.style.left = '710px';
                transitionLinesLayer.style.width = '710px';
                transitionLinesLayer.style.opacity = '0.6';
            }
            
            console.log('[MessageBox] Showing message:', text);
            
            // Auto-hide after duration
            hideTimeout = setTimeout(() => {
                hideMessage();
            }, duration);
        }
        
        // Function to hide message
        function hideMessage() {
            // Trigger animation - slide out to right
            messageBoxContainer.style.left = '355px';
            messageBoxContainer.style.width = '0px';
            messageBoxContainer.style.opacity = '0';
            
            // Reset transition lines
            if (transitionLinesLayer) {
                transitionLinesLayer.style.left = '-240px';
                transitionLinesLayer.style.width = '0px';
                transitionLinesLayer.style.opacity = '0';
            }
            
            // Hide message box layer
            messageBoxLayer.style.opacity = '0';
            
            console.log('[MessageBox] Message hidden');
            
            // Mark as no longer displaying and process next in queue
            isDisplaying = false;
            processQueue();
        }
        
        console.log('[MessageBox] Overlay loaded');
        
    </script>
</body>
</html>
